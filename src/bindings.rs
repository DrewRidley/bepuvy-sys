/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _LIBCPP_ABI_VERSION: u32 = 1;
pub const _LIBCPP_ENABLE_ASSERTIONS_DEFAULT: u32 = 0;
pub const _LIBCPP_VERSION: u32 = 15006;
pub const _LIBCPP_STD_VER: u32 = 14;
pub const _LIBCPP_OBJECT_FORMAT_MACHO: u32 = 1;
pub const _LIBCPP_LOCALE__L_EXTENSIONS: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 130300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const _LIBCPP_ENABLE_ASSERTIONS: u32 = 0;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_transparent_operators: u32 = 201210;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;

pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std__BoolConstant = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
pub type std__IsSame = std__BoolConstant;
pub type std__IsNotSame = std__BoolConstant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___is_referenceable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___is_referenceable_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___is_referenceable_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_referenceable_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___is_referenceable_impl))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _address: u8,
}
pub type std___add_lvalue_reference_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std_add_lvalue_reference_type = u8;
pub type std_add_lvalue_reference_t = std_add_lvalue_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _address: u8,
}
pub type std___enable_if_t = u8;
pub type std_enable_if_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
pub type std_remove_const_t = std_remove_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
pub type std_remove_volatile_t = std_remove_volatile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type = std_remove_volatile;
pub type std_remove_cv_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_integral {
    pub _address: u8,
}
pub const std___libcpp_is_integral_value: std___libcpp_is_integral__bindgen_ty_1 = 0;
pub type std___libcpp_is_integral__bindgen_ty_1 = i32;
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
pub type std_remove_reference_t = std_remove_reference;
pub type std___apply_cv_type<_Up> = _Up;
pub type std__If = u8;
pub type std_conditional_type<_If> = _If;
pub type std_conditional_t = u8;
pub type std___conditional_t = u8;
pub type std___add_pointer_impl_type = *mut std_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_add_pointer_type = u8;
pub type std_add_pointer_t = std_add_pointer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
pub type std_remove_extent_t = std_remove_extent;
pub type std___decay_type = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay__Up = std_remove_reference;
pub type std_decay_type = u8;
pub type std_decay_t = std_decay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_core_convertible {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_member_pointer {
    pub _address: u8,
}
pub const std___libcpp_is_member_pointer___is_member: std___libcpp_is_member_pointer__bindgen_ty_1 =
    0;
pub const std___libcpp_is_member_pointer___is_func: std___libcpp_is_member_pointer__bindgen_ty_1 =
    0;
pub const std___libcpp_is_member_pointer___is_obj: std___libcpp_is_member_pointer__bindgen_ty_1 = 0;
pub type std___libcpp_is_member_pointer__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_reference_wrapper_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_reference_wrapper {
    pub _base: std___is_reference_wrapper_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nat {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nat() {
    assert_eq!(
        ::std::mem::size_of::<std___nat>(),
        1usize,
        concat!("Size of: ", stringify!(std___nat))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nat>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nat))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___any {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___any() {
    assert_eq!(
        ::std::mem::size_of::<std___any>(),
        1usize,
        concat!("Size of: ", stringify!(std___any))
    );
    assert_eq!(
        ::std::mem::align_of::<std___any>(),
        1usize,
        concat!("Alignment of ", stringify!(std___any))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNSt3__15__anyC1Ez"]
    pub fn std___any___any(this: *mut std___any, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_pointer_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___member_pointer_class_type {
    pub _address: u8,
}
pub type std___enable_if_bullet1 = u8;
pub type std___enable_if_bullet2 = u8;
pub type std___enable_if_bullet3 = u8;
pub type std___enable_if_bullet4 = u8;
pub type std___enable_if_bullet5 = u8;
pub type std___enable_if_bullet6 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invokable_r {
    pub _address: u8,
}
pub type std___invokable_r__Result<_Fp> = _Fp;
pub type std___invokable_r_type = u8;
pub type std___invokable = std___invokable_r;
pub type std___nothrow_invokable_r = u8;
pub type std___nothrow_invokable = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
pub type std_add_const_t = std_add_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type<_Tp> = _Tp;
pub type std_add_cv_t = std_add_cv;
pub type std___add_rvalue_reference_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_add_rvalue_reference_type = u8;
pub type std_add_rvalue_reference_t = std_add_rvalue_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
pub type std_add_volatile_t = std_add_volatile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_list {
    pub _address: u8,
}
pub type std___type_list__Head<_Hp> = _Hp;
pub type std___type_list__Tail<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___align_type {
    pub _address: u8,
}
pub type std___align_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___struct_double {
    pub __lx: f64,
}
#[test]
fn bindgen_test_layout_std___struct_double() {
    const UNINIT: ::std::mem::MaybeUninit<std___struct_double> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___struct_double>(),
        8usize,
        concat!("Size of: ", stringify!(std___struct_double))
    );
    assert_eq!(
        ::std::mem::align_of::<std___struct_double>(),
        8usize,
        concat!("Alignment of ", stringify!(std___struct_double))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___struct_double),
            "::",
            stringify!(__lx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___struct_double4 {
    pub __lx: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_std___struct_double4() {
    const UNINIT: ::std::mem::MaybeUninit<std___struct_double4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<std___struct_double4>(),
        32usize,
        concat!("Size of: ", stringify!(std___struct_double4))
    );
    assert_eq!(
        ::std::mem::align_of::<std___struct_double4>(),
        8usize,
        concat!("Alignment of ", stringify!(std___struct_double4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___struct_double4),
            "::",
            stringify!(__lx)
        )
    );
}
pub type std___all_types = std___type_list;
extern "C" {
    #[link_name = "\u{1}__min"]
    pub static std___select_align___min: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}__max"]
    pub static std___select_align___max: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___select_align_value: ::std::os::raw::c_ulong;
}
pub type std_aligned_storage__Aligner = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __align: std_aligned_storage__Aligner,
    pub __data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
pub type std_aligned_storage_t = u8;
pub type std_aligned_union_type = u8;
pub type std_aligned_union_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
pub type std___uncvref_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_same_uncvref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___void_t {
    pub _address: u8,
}
pub type std___void_t_type = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type2_imp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_common_type_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_common_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_common_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_common_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_common_type)
        )
    );
}
pub type std_common_type_t = std_common_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___copy_cv {
    pub _address: u8,
}
pub type std___copy_cv_type<_To> = _To;
pub type std___copy_cv_t = std___copy_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___copy_cvref {
    pub _address: u8,
}
pub type std___copy_cvref_type = std___copy_cv_t;
pub type std___copy_cvref_t = std___copy_cvref;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
pub type std___expand_to_true = std_true_type;
pub type std__And<_Pred> = _Pred;
pub type std__Or = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std_remove_all_extents_t = std_remove_all_extents;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_floating_point {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_float_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_floating_point_open0_long_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_floating_point>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_floating_point)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _base: std___libcpp_is_floating_point,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___select_2nd {
    pub _address: u8,
}
pub type std___select_2nd_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_bounded_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_callable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t_impl {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_nullptr_t_impl_open0_nullptr_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___is_nullptr_t_impl>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_nullptr_t_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_nullptr_t_impl>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_nullptr_t_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _base: std___is_nullptr_t_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _base: std___is_nullptr_t_impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_apply {
    pub _address: u8,
}
pub type std___is_destructible_apply_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructor_wellformed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_is_destructible_open0_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_is_destructible>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_is_destructible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_is_destructible>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_is_destructible)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Lazy {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
pub type std_underlying_type_t = std_underlying_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_unbounded_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
pub type std___signed_types = std___type_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = std_make_signed;
pub type std___unsigned_types = std___type_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
pub type std_make_unsigned_t = std_make_unsigned;
pub type std___copy_unsigned_t = std___conditional_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_type<_Tp> = _Tp;
pub type std_remove_pointer_t = std_remove_pointer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Tp> = _Tp;
pub type std___type_identity_t = std___type_identity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unconstref {
    pub _address: u8,
}
pub type std___unconstref_type = std_remove_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
pub type std_result_of_t = std_result_of;
pub type std___swap_result_t = u8;
pub type std___detail___swappable_with___swap1<_Tp> = _Tp;
pub type std___detail___swappable_with___swap2<_Up> = _Up;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
pub type std___sfinae_underlying_type_type = std_underlying_type;
pub type std___sfinae_underlying_type___promoted_type = std___sfinae_underlying_type_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_fail_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_fail_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_fail_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_fail_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_fail_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_fail_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_self_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_self_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_self_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_self_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_self_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_self_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___extract_key_first_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___extract_key_first_tag() {
    assert_eq!(
        ::std::mem::size_of::<std___extract_key_first_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std___extract_key_first_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std___extract_key_first_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std___extract_key_first_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_extract_key {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___can_extract_map_key {
    pub _address: u8,
}


pub type std___make_const_lvalue_ref = *mut std_remove_reference;
pub type std___maybe_const = u8;
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
pub type std___libcpp_numeric_limits_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
pub type std_numeric_limits___base = u8;
pub type std_numeric_limits_type = std_numeric_limits___base;
extern "C" {
    #[link_name = "\u{1}is_specialized"]
    pub static std_is_specialized: bool;
}
extern "C" {
    #[link_name = "\u{1}digits"]
    pub static std_digits: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}digits10"]
    pub static std_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_digits10"]
    pub static std_max_digits10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}is_signed"]
    pub static std_is_signed: bool;
}
extern "C" {
    #[link_name = "\u{1}is_integer"]
    pub static std_is_integer: bool;
}
extern "C" {
    #[link_name = "\u{1}is_exact"]
    pub static std_is_exact: bool;
}
extern "C" {
    #[link_name = "\u{1}radix"]
    pub static std_radix: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}min_exponent"]
    pub static std_min_exponent: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}min_exponent10"]
    pub static std_min_exponent10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_exponent"]
    pub static std_max_exponent: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_exponent10"]
    pub static std_max_exponent10: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}has_infinity"]
    pub static std_has_infinity: bool;
}
extern "C" {
    #[link_name = "\u{1}has_quiet_NaN"]
    pub static std_has_quiet_NaN: bool;
}
extern "C" {
    #[link_name = "\u{1}has_signaling_NaN"]
    pub static std_has_signaling_NaN: bool;
}
extern "C" {
    #[link_name = "\u{1}has_denorm"]
    pub static std_has_denorm: std_float_denorm_style;
}
extern "C" {
    #[link_name = "\u{1}has_denorm_loss"]
    pub static std_has_denorm_loss: bool;
}
extern "C" {
    #[link_name = "\u{1}is_iec559"]
    pub static std_is_iec559: bool;
}
extern "C" {
    #[link_name = "\u{1}is_bounded"]
    pub static std_is_bounded: bool;
}
extern "C" {
    #[link_name = "\u{1}is_modulo"]
    pub static std_is_modulo: bool;
}
extern "C" {
    #[link_name = "\u{1}traps"]
    pub static std_traps: bool;
}
extern "C" {
    #[link_name = "\u{1}tinyness_before"]
    pub static std_tinyness_before: bool;
}
extern "C" {
    #[link_name = "\u{1}round_style"]
    pub static std_round_style: std_float_round_style;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_reserved: [u64; 14usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut u32, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const u32, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector3 {
    pub X: f32,
    pub Y: f32,
    pub Z: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Vector3() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Vector3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector3>(),
        12usize,
        concat!("Size of: ", stringify!(Bepu_Vector3))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector3>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Vector3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3),
            "::",
            stringify!(Z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Quaternion {
    pub X: f32,
    pub Y: f32,
    pub Z: f32,
    pub W: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Quaternion() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Quaternion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Quaternion>(),
        16usize,
        concat!("Size of: ", stringify!(Bepu_Quaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Quaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Quaternion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Quaternion),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Quaternion),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Quaternion),
            "::",
            stringify!(Z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Quaternion),
            "::",
            stringify!(W)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector128F {
    pub V0: f32,
    pub V1: f32,
    pub V2: f32,
    pub V3: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Vector128F() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Vector128F> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector128F>(),
        16usize,
        concat!("Size of: ", stringify!(Bepu_Vector128F))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector128F>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Vector128F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128F),
            "::",
            stringify!(V0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128F),
            "::",
            stringify!(V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128F),
            "::",
            stringify!(V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128F),
            "::",
            stringify!(V3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector256F {
    pub V0: f32,
    pub V1: f32,
    pub V2: f32,
    pub V3: f32,
    pub V4: f32,
    pub V5: f32,
    pub V6: f32,
    pub V7: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Vector256F() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Vector256F> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector256F>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_Vector256F))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector256F>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Vector256F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V4) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V5) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V6) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V7) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256F),
            "::",
            stringify!(V7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector128I {
    pub V0: i32,
    pub V1: i32,
    pub V2: i32,
    pub V3: i32,
}
#[test]
fn bindgen_test_layout_Bepu_Vector128I() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Vector128I> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector128I>(),
        16usize,
        concat!("Size of: ", stringify!(Bepu_Vector128I))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector128I>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Vector128I))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128I),
            "::",
            stringify!(V0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128I),
            "::",
            stringify!(V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128I),
            "::",
            stringify!(V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector128I),
            "::",
            stringify!(V3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector256I {
    pub V0: i32,
    pub V1: i32,
    pub V2: i32,
    pub V3: i32,
    pub V4: i32,
    pub V5: i32,
    pub V6: i32,
    pub V7: i32,
}
#[test]
fn bindgen_test_layout_Bepu_Vector256I() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Vector256I> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector256I>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_Vector256I))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector256I>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Vector256I))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V4) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V5) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V6) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).V7) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector256I),
            "::",
            stringify!(V7)
        )
    );
}
#[doc = " <summary>\n Represents a rigid transformation.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_RigidPose {
    #[doc = " <summary>\n Orientation of the pose.\n </summary>"]
    pub Orientation: Bepu_Quaternion,
    #[doc = " <summary>\n Position of the pose.\n </summary>"]
    pub Position: Bepu_Vector3,
    pub Pad: i32,
}
#[test]
fn bindgen_test_layout_Bepu_RigidPose() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_RigidPose> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_RigidPose>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_RigidPose))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_RigidPose>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_RigidPose))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Orientation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_RigidPose),
            "::",
            stringify!(Orientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Position) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_RigidPose),
            "::",
            stringify!(Position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pad) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_RigidPose),
            "::",
            stringify!(Pad)
        )
    );
}
#[doc = " <summary>\n Lower left triangle (including diagonal) of a symmetric 3x3 matrix.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Symmetric3x3 {
    #[doc = " <summary>\n First row, first column of the matrix.\n </summary>"]
    pub XX: f32,
    #[doc = " <summary>\n Second row, first column of the matrix.\n </summary>"]
    pub YX: f32,
    #[doc = " <summary>\n Second row, second column of the matrix.\n </summary>"]
    pub YY: f32,
    #[doc = " <summary>\n Third row, first column of the matrix.\n </summary>"]
    pub ZX: f32,
    #[doc = " <summary>\n Third row, second column of the matrix.\n </summary>"]
    pub ZY: f32,
    #[doc = " <summary>\n Third row, third column of the matrix.\n </summary>"]
    pub ZZ: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Symmetric3x3() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Symmetric3x3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Symmetric3x3>(),
        24usize,
        concat!("Size of: ", stringify!(Bepu_Symmetric3x3))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Symmetric3x3>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Symmetric3x3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Symmetric3x3),
            "::",
            stringify!(XX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).YX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Symmetric3x3),
            "::",
            stringify!(YX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).YY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Symmetric3x3),
            "::",
            stringify!(YY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ZX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Symmetric3x3),
            "::",
            stringify!(ZX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ZY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Symmetric3x3),
            "::",
            stringify!(ZY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ZZ) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Symmetric3x3),
            "::",
            stringify!(ZZ)
        )
    );
}
#[doc = " <summary>\n Vector3Wide interop type used when <see cref=\"Vector{float}\"/> is 128 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector3SIMD128 {
    pub X: Bepu_Vector128F,
    pub Y: Bepu_Vector128F,
    pub Z: Bepu_Vector128F,
}
#[test]
fn bindgen_test_layout_Bepu_Vector3SIMD128() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Vector3SIMD128> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector3SIMD128>(),
        48usize,
        concat!("Size of: ", stringify!(Bepu_Vector3SIMD128))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector3SIMD128>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Vector3SIMD128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3SIMD128),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3SIMD128),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3SIMD128),
            "::",
            stringify!(Z)
        )
    );
}
#[doc = " <summary>\n Vector3Wide interop type used when <see cref=\"Vector{float}\"/> is 256 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector3SIMD256 {
    pub X: Bepu_Vector256F,
    pub Y: Bepu_Vector256F,
    pub Z: Bepu_Vector256F,
}
#[test]
fn bindgen_test_layout_Bepu_Vector3SIMD256() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Vector3SIMD256> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector3SIMD256>(),
        96usize,
        concat!("Size of: ", stringify!(Bepu_Vector3SIMD256))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector3SIMD256>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Vector3SIMD256))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3SIMD256),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3SIMD256),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Vector3SIMD256),
            "::",
            stringify!(Z)
        )
    );
}
#[doc = " <summary>\n QuaternionWide interop type used when <see cref=\"Vector{float}\"/> is 128 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_QuaternionSIMD128 {
    pub X: Bepu_Vector128F,
    pub Y: Bepu_Vector128F,
    pub Z: Bepu_Vector128F,
}
#[test]
fn bindgen_test_layout_Bepu_QuaternionSIMD128() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_QuaternionSIMD128> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_QuaternionSIMD128>(),
        48usize,
        concat!("Size of: ", stringify!(Bepu_QuaternionSIMD128))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_QuaternionSIMD128>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_QuaternionSIMD128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_QuaternionSIMD128),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_QuaternionSIMD128),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_QuaternionSIMD128),
            "::",
            stringify!(Z)
        )
    );
}
#[doc = " <summary>\n QuaternionWide interop type used when <see cref=\"Vector{float}\"/> is 256 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_QuaternionSIMD256 {
    pub X: Bepu_Vector256F,
    pub Y: Bepu_Vector256F,
    pub Z: Bepu_Vector256F,
}
#[test]
fn bindgen_test_layout_Bepu_QuaternionSIMD256() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_QuaternionSIMD256> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_QuaternionSIMD256>(),
        96usize,
        concat!("Size of: ", stringify!(Bepu_QuaternionSIMD256))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_QuaternionSIMD256>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_QuaternionSIMD256))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_QuaternionSIMD256),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_QuaternionSIMD256),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_QuaternionSIMD256),
            "::",
            stringify!(Z)
        )
    );
}
#[doc = " <summary>\n BodyInertiaWide interop type used when <see cref=\"Vector{float}\"/> is 128 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyInertiaSIMD128 {
    pub InverseInertiaXX: Bepu_Vector128F,
    pub InverseInertiaYX: Bepu_Vector128F,
    pub InverseInertiaYY: Bepu_Vector128F,
    pub InverseInertiaZX: Bepu_Vector128F,
    pub InverseInertiaZY: Bepu_Vector128F,
    pub InverseInertiaZZ: Bepu_Vector128F,
    pub InverseMass: Bepu_Vector128F,
}
#[test]
fn bindgen_test_layout_Bepu_BodyInertiaSIMD128() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyInertiaSIMD128> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyInertiaSIMD128>(),
        112usize,
        concat!("Size of: ", stringify!(Bepu_BodyInertiaSIMD128))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyInertiaSIMD128>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyInertiaSIMD128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaXX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD128),
            "::",
            stringify!(InverseInertiaXX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaYX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD128),
            "::",
            stringify!(InverseInertiaYX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaYY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD128),
            "::",
            stringify!(InverseInertiaYY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaZX) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD128),
            "::",
            stringify!(InverseInertiaZX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaZY) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD128),
            "::",
            stringify!(InverseInertiaZY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaZZ) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD128),
            "::",
            stringify!(InverseInertiaZZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseMass) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD128),
            "::",
            stringify!(InverseMass)
        )
    );
}
#[doc = " <summary>\n BodyInertiaWide interop type used when <see cref=\"Vector{float}\"/> is 256 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyInertiaSIMD256 {
    pub InverseInertiaXX: Bepu_Vector256F,
    pub InverseInertiaYX: Bepu_Vector256F,
    pub InverseInertiaYY: Bepu_Vector256F,
    pub InverseInertiaZX: Bepu_Vector256F,
    pub InverseInertiaZY: Bepu_Vector256F,
    pub InverseInertiaZZ: Bepu_Vector256F,
    pub InverseMass: Bepu_Vector256F,
}
#[test]
fn bindgen_test_layout_Bepu_BodyInertiaSIMD256() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyInertiaSIMD256> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyInertiaSIMD256>(),
        224usize,
        concat!("Size of: ", stringify!(Bepu_BodyInertiaSIMD256))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyInertiaSIMD256>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyInertiaSIMD256))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaXX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD256),
            "::",
            stringify!(InverseInertiaXX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaYX) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD256),
            "::",
            stringify!(InverseInertiaYX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaYY) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD256),
            "::",
            stringify!(InverseInertiaYY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaZX) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD256),
            "::",
            stringify!(InverseInertiaZX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaZY) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD256),
            "::",
            stringify!(InverseInertiaZY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaZZ) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD256),
            "::",
            stringify!(InverseInertiaZZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseMass) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertiaSIMD256),
            "::",
            stringify!(InverseMass)
        )
    );
}
#[doc = " <summary>\n BodyVelocityWide interop type used when <see cref=\"Vector{float}\"/> is 128 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyVelocitySIMD128 {
    pub Linear: Bepu_Vector3SIMD128,
    pub Angular: Bepu_Vector3SIMD128,
}
#[test]
fn bindgen_test_layout_Bepu_BodyVelocitySIMD128() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyVelocitySIMD128> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyVelocitySIMD128>(),
        96usize,
        concat!("Size of: ", stringify!(Bepu_BodyVelocitySIMD128))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyVelocitySIMD128>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyVelocitySIMD128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocitySIMD128),
            "::",
            stringify!(Linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Angular) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocitySIMD128),
            "::",
            stringify!(Angular)
        )
    );
}
#[doc = " <summary>\n BodyVelocityWide interop type used when <see cref=\"Vector{float}\"/> is 256 bits wide.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyVelocitySIMD256 {
    pub Linear: Bepu_Vector3SIMD256,
    pub Angular: Bepu_Vector3SIMD256,
}
#[test]
fn bindgen_test_layout_Bepu_BodyVelocitySIMD256() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyVelocitySIMD256> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyVelocitySIMD256>(),
        192usize,
        concat!("Size of: ", stringify!(Bepu_BodyVelocitySIMD256))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyVelocitySIMD256>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyVelocitySIMD256))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocitySIMD256),
            "::",
            stringify!(Linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Angular) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocitySIMD256),
            "::",
            stringify!(Angular)
        )
    );
}
#[doc = " <summary>\n Represents an index with an associated type packed into a single integer.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_TypedIndex {
    #[doc = " <summary>\n Bit packed representation of the typed index.\n </summary>"]
    pub Packed: u32,
}
#[test]
fn bindgen_test_layout_Bepu_TypedIndex() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_TypedIndex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_TypedIndex>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_TypedIndex))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_TypedIndex>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_TypedIndex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Packed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_TypedIndex),
            "::",
            stringify!(Packed)
        )
    );
}
#[doc = " <summary>\n Points to an instance in an instance directory.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_InstanceHandle {
    pub RawValue: i32,
}
#[test]
fn bindgen_test_layout_Bepu_InstanceHandle() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_InstanceHandle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_InstanceHandle>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_InstanceHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_InstanceHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_InstanceHandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RawValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_InstanceHandle),
            "::",
            stringify!(RawValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyHandle {
    pub Value: i32,
}
#[test]
fn bindgen_test_layout_Bepu_BodyHandle() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyHandle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyHandle>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_BodyHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyHandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyHandle),
            "::",
            stringify!(Value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_StaticHandle {
    pub Value: i32,
}
#[test]
fn bindgen_test_layout_Bepu_StaticHandle() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_StaticHandle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_StaticHandle>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_StaticHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_StaticHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_StaticHandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_StaticHandle),
            "::",
            stringify!(Value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_ConstraintHandle {
    pub Value: i32,
}
#[test]
fn bindgen_test_layout_Bepu_ConstraintHandle() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_ConstraintHandle> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_ConstraintHandle>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_ConstraintHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_ConstraintHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_ConstraintHandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConstraintHandle),
            "::",
            stringify!(Value)
        )
    );
}
#[doc = " <summary>\n Points to an instance in an instance directory.\n </summary>"]
pub type Bepu_SimulationHandle = Bepu_InstanceHandle;
#[doc = " <summary>\n Points to an instance in an instance directory.\n </summary>"]
pub type Bepu_BufferPoolHandle = Bepu_InstanceHandle;
#[doc = " <summary>\n Points to an instance in an instance directory.\n </summary>"]
pub type Bepu_ThreadDispatcherHandle = Bepu_InstanceHandle;
#[doc = " <summary>\n <para>No sweep tests are performed. Default speculative contact generation will occur within the speculative margin.</para>\n <para>The collidable's bounding box will not be expanded by velocity beyond the speculative margin.</para>\n <para>This is the cheapest mode. If a Discrete mode collidable is moving quickly and the maximum speculative margin is limited,\n the fact that its bounding box is not expanded may cause it to miss a collision even with a non-Discrete collidable.</para>\n </summary>"]
pub const Bepu_ContinuousDetectionMode_Discrete: Bepu_ContinuousDetectionMode = 0;
#[doc = " <summary>\n <para>No sweep tests are performed. Default speculative contact generation will occur within the speculative margin.</para>\n <para>The collidable's bounding box will be expanded by velocity without being limited by the speculative margin.</para>\n <para>This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes\n that should avoid missing collisions.</para>\n </summary>"]
pub const Bepu_ContinuousDetectionMode_Passive: Bepu_ContinuousDetectionMode = 1;
#[doc = " <summary>\n <para>Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision.</para>\n <para>This mode can capture angular motion with very few ghost collisions. It can, however, miss secondary collisions that would have occurred due to the primary impact's velocity change.</para>\n </summary>"]
pub const Bepu_ContinuousDetectionMode_Continuous: Bepu_ContinuousDetectionMode = 2;
#[doc = " <summary>\n Defines how a collidable will handle collision detection in the presence of velocity.\n </summary>"]
pub type Bepu_ContinuousDetectionMode = u32;
#[doc = " <summary>\n Defines how a collidable handles collisions with significant velocity.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_ContinuousDetection {
    #[doc = " <summary>\n The continuous collision detection mode.\n </summary>"]
    pub Mode: Bepu_ContinuousDetectionMode,
    #[doc = " <summary>\n If using <see cref=\"ContinuousDetectionMode.Continuous\"/>, this defines the minimum progress that the sweep test will make when searching for the first time of impact.\n Collisions lasting less than <see cref=\"MinimumSweepTimestep\"/> may be missed by the sweep test. Using larger values can significantly increase the performance of sweep tests.\n </summary>"]
    pub MinimumSweepTimestep: f32,
    #[doc = " <summary>\n If using <see cref=\"ContinuousDetectionMode.Continuous\"/>, sweep tests will terminate if the time of impact region has been refined to be smaller than <see cref=\"SweepConvergenceThreshold\"/>.\n Values closer to zero will converge more closely to the true time of impact, but for speculative contact generation larger values usually work fine.\n Larger values allow the sweep to terminate much earlier and can significantly improve sweep performance.\n </summary>"]
    pub SweepConvergenceThreshold: f32,
}
#[test]
fn bindgen_test_layout_Bepu_ContinuousDetection() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_ContinuousDetection> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_ContinuousDetection>(),
        12usize,
        concat!("Size of: ", stringify!(Bepu_ContinuousDetection))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_ContinuousDetection>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_ContinuousDetection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ContinuousDetection),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumSweepTimestep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ContinuousDetection),
            "::",
            stringify!(MinimumSweepTimestep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SweepConvergenceThreshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ContinuousDetection),
            "::",
            stringify!(SweepConvergenceThreshold)
        )
    );
}
#[doc = " <summary>\n Description of a collidable used by a body living in the broad phase and able to generate collision pairs.\n Collidables with a ShapeIndex that points to nothing (a default constructed <see cref=\"TypedIndex\"/>) are not capable of colliding with anything.\n This can be used for a body which needs no collidable representation.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Collidable {
    #[doc = " <summary>\n Index of the shape used by the body. While this can be changed, any transition from shapeless->shapeful or shapeful->shapeless must be reported to the broad phase.\n If you need to perform such a transition, consider using <see cref=\"Bodies.SetShape\"/> or <see cref=\"Bodies.ApplyDescription\"/>; those functions update the relevant state.\n </summary>"]
    pub Shape: Bepu_TypedIndex,
    #[doc = " <summary>\n Continuous collision detection settings for this collidable. Includes the collision detection mode to use and tuning variables associated with those modes.\n </summary>"]
    pub Continuity: Bepu_ContinuousDetection,
    #[doc = " <summary>\n Lower bound on the value of the speculative margin used by the collidable.\n </summary>\n <remarks>0 tends to be a good default value. Higher values can be chosen if velocity magnitude is a poor proxy for speculative margins, but these cases are rare.\n In those cases, try to use the smallest value that still satisfies requirements to avoid creating unnecessary contact constraints.</remarks>"]
    pub MinimumSpeculativeMargin: f32,
    #[doc = " <summary>\n Upper bound on the value of the speculative margin used by the collidable.\n </summary>\n <remarks><see cref=\"float.MaxValue\"/> tends to be a good default value for discrete or passive mode collidables.\n The speculative margin will increase in size proportional to velocity magnitude, so having an unlimited maximum won't cost extra if the body isn't moving fast.\n <para>Smaller values can be useful for improving performance in chaotic situations where missing a collision is acceptable. When using <see cref=\"ContinuousDetectionMode.Continuous\"/>, a speculative margin larger than the velocity magnitude will result in the sweep test being skipped, so lowering the maximum margin can help avoid ghost collisions.</para>\n </remarks>"]
    pub MaximumSpeculativeMargin: f32,
    #[doc = " <summary>\n Automatically computed size of the margin around the surface of the shape in which contacts can be generated. These contacts will have negative depth and only contribute if the frame's velocities\n would push the shapes of a pair into overlap.\n <para>This is automatically set by bounding box prediction each frame, and is bound by the collidable's <see cref=\"MinimumSpeculativeMargin\"/> and <see cref=\"MaximumSpeculativeMargin\"/> values.\n The effective speculative margin for a collision pair can also be modified from <see cref=\"INarrowPhaseCallbacks\"/> callbacks.</para>\n <para>This should be positive to avoid jittering.</para>\n <para>It can also be used as a form of continuous collision detection, but excessively high values combined with fast motion may result in visible 'ghost collision' artifacts.\n For continuous collision detection with less chance of ghost collisions, use <see cref=\"ContinuousDetectionMode.Continuous\"/>.</para>\n <para>If using <see cref=\"ContinuousDetectionMode.Continuous\"/>, consider setting <see cref=\"MaximumSpeculativeMargin\"/> to a smaller value to help filter ghost collisions.</para>\n <para>For more information, see the ContinuousCollisionDetection.md documentation.</para>\n </summary>"]
    pub SpeculativeMargin: f32,
    #[doc = " <summary>\n Index of the collidable in the broad phase. Used to look up the target location for bounding box scatters. Under normal circumstances, this should not be set externally.\n </summary>"]
    pub BroadPhaseIndex: i32,
}
#[test]
fn bindgen_test_layout_Bepu_Collidable() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Collidable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Collidable>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_Collidable))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Collidable>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Collidable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Shape) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Collidable),
            "::",
            stringify!(Shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Continuity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Collidable),
            "::",
            stringify!(Continuity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumSpeculativeMargin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Collidable),
            "::",
            stringify!(MinimumSpeculativeMargin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumSpeculativeMargin) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Collidable),
            "::",
            stringify!(MaximumSpeculativeMargin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpeculativeMargin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Collidable),
            "::",
            stringify!(SpeculativeMargin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BroadPhaseIndex) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Collidable),
            "::",
            stringify!(BroadPhaseIndex)
        )
    );
}
#[doc = " <summary>\n Linear and angular velocity for a body.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyVelocity {
    #[doc = " <summary>\n Linear velocity associated with the body.\n </summary>"]
    pub Linear: Bepu_Vector3,
    pub Pad0: i32,
    #[doc = " <summary>\n Angular velocity associated with the body.\n </summary>"]
    pub Angular: Bepu_Vector3,
    pub Pad1: i32,
}
#[test]
fn bindgen_test_layout_Bepu_BodyVelocity() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyVelocity> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyVelocity>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_BodyVelocity))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyVelocity>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyVelocity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocity),
            "::",
            stringify!(Linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pad0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocity),
            "::",
            stringify!(Pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Angular) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocity),
            "::",
            stringify!(Angular)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pad1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyVelocity),
            "::",
            stringify!(Pad1)
        )
    );
}
#[doc = " <summary>\n Describes the pose and velocity of a body.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_MotionState {
    #[doc = " <summary>\n Pose of the body.\n </summary>"]
    pub Pose: Bepu_RigidPose,
    #[doc = " <summary>\n Linear and angular velocity of the body.\n </summary>"]
    pub Velocity: Bepu_BodyVelocity,
}
#[test]
fn bindgen_test_layout_Bepu_MotionState() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_MotionState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_MotionState>(),
        64usize,
        concat!("Size of: ", stringify!(Bepu_MotionState))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_MotionState>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_MotionState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_MotionState),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Velocity) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_MotionState),
            "::",
            stringify!(Velocity)
        )
    );
}
#[doc = " <summary>\n Stores the inertia for a body.\n </summary>\n <remarks>This representation stores the inverse mass and inverse inertia tensor. Most of the high frequency use cases in the engine naturally use the inverse.</remarks>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyInertia {
    #[doc = " <summary>\n Inverse of the body's inertia tensor.\n </summary>"]
    pub InverseInertiaTensor: Bepu_Symmetric3x3,
    #[doc = " <summary>\n Inverse of the body's mass.\n </summary>"]
    pub InverseMass: f32,
    pub Pad: u32,
}
#[test]
fn bindgen_test_layout_Bepu_BodyInertia() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyInertia> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyInertia>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_BodyInertia))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyInertia>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyInertia))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseInertiaTensor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertia),
            "::",
            stringify!(InverseInertiaTensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseMass) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertia),
            "::",
            stringify!(InverseMass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pad) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertia),
            "::",
            stringify!(Pad)
        )
    );
}
#[doc = " <summary>\n Stores the local and world views of a body's inertia, packed together for efficient access.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyInertias {
    #[doc = " <summary>\n Local inertia of the body.\n </summary>"]
    pub Local: Bepu_BodyInertia,
    #[doc = " <summary>\n Transformed world inertia of the body. Note that this is only valid between the velocity integration that updates it and the pose integration that follows.\n Outside of that execution window, this should be considered undefined.\n </summary>\n <remarks>\n We cache this here because velocity integration wants both the local and world inertias, and any integration happening within the solver will do so without the benefit of sequential loads.\n In that context, being able to load a single cache line to grab both local and world inertia helps quite a lot.</remarks>"]
    pub World: Bepu_BodyInertia,
}
#[test]
fn bindgen_test_layout_Bepu_BodyInertias() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyInertias> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyInertias>(),
        64usize,
        concat!("Size of: ", stringify!(Bepu_BodyInertias))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyInertias>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyInertias))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Local) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertias),
            "::",
            stringify!(Local)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).World) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyInertias),
            "::",
            stringify!(World)
        )
    );
}
#[doc = " <summary>\n Stores all body information needed by the solver together.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyDynamics {
    #[doc = " <summary>\n Pose and velocity information for the body.\n </summary>"]
    pub Motion: Bepu_MotionState,
    #[doc = " <summary>\n Inertia information for the body.\n </summary>"]
    pub Inertia: Bepu_BodyInertias,
}
#[test]
fn bindgen_test_layout_Bepu_BodyDynamics() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyDynamics> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyDynamics>(),
        128usize,
        concat!("Size of: ", stringify!(Bepu_BodyDynamics))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyDynamics>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyDynamics))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Motion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyDynamics),
            "::",
            stringify!(Motion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Inertia) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyDynamics),
            "::",
            stringify!(Inertia)
        )
    );
}
#[doc = " <summary>\n Describes how a body sleeps, and its current state with respect to sleeping.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyActivity {
    #[doc = " <summary>\n Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).\n Setting this to a negative value guarantees the body cannot go to sleep without user action.\n </summary>"]
    pub SleepThreshold: f32,
    #[doc = " <summary>\n The number of time steps that the body must be under the sleep threshold before the body becomes a sleeping candidate.\n Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.\n </summary>"]
    pub MinimumTimestepsUnderThreshold: u8,
    #[doc = " <summary>\n If the body is awake, this is the number of time steps that the body has had a velocity below the sleep threshold.\n </summary>"]
    pub TimestepsUnderThresholdCount: u8,
    #[doc = " <summary>\n True if this body is a candidate for being slept. If all the bodies that it is connected to by constraints are also candidates, this body may go to sleep.\n </summary>"]
    pub SleepCandidate: bool,
}
#[test]
fn bindgen_test_layout_Bepu_BodyActivity() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyActivity> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyActivity>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_BodyActivity))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyActivity>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyActivity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SleepThreshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyActivity),
            "::",
            stringify!(SleepThreshold)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).MinimumTimestepsUnderThreshold) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyActivity),
            "::",
            stringify!(MinimumTimestepsUnderThreshold)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TimestepsUnderThresholdCount) as usize - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyActivity),
            "::",
            stringify!(TimestepsUnderThresholdCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SleepCandidate) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyActivity),
            "::",
            stringify!(SleepCandidate)
        )
    );
}
#[doc = " <summary>\n Describes a collidable and how it should handle continuous collision detection.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_CollidableDescription {
    #[doc = " <summary>\n Shape of the collidable.\n </summary>"]
    pub Shape: Bepu_TypedIndex,
    #[doc = " <summary>\n Continuous collision detection settings used by the collidable.\n </summary>"]
    pub Continuity: Bepu_ContinuousDetection,
    #[doc = " <summary>\n Lower bound on the value of the speculative margin used by the collidable.\n </summary>\n <remarks>0 tends to be a good default value. Higher values can be chosen if velocity magnitude is a poor proxy for speculative margins, but these cases are rare.\n In those cases, try to use the smallest value that still satisfies requirements to avoid creating unnecessary contact constraints.</remarks>"]
    pub MinimumSpeculativeMargin: f32,
    #[doc = " <summary>\n Upper bound on the value of the speculative margin used by the collidable.\n </summary>\n <remarks><see cref=\"float.MaxValue\"/> tends to be a good default value for discrete or passive mode collidables.\n The speculative margin will increase in size proportional to velocity magnitude, so having an unlimited maximum won't cost extra if the body isn't moving fast.\n <para>Smaller values can be useful for improving performance in chaotic situations where missing a collision is acceptable. When using <see cref=\"ContinuousDetectionMode.Continuous\"/>, a speculative margin larger than the velocity magnitude will result in the sweep test being skipped, so lowering the maximum margin can help avoid ghost collisions.</para>\n </remarks>"]
    pub MaximumSpeculativeMargin: f32,
}
#[test]
fn bindgen_test_layout_Bepu_CollidableDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_CollidableDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_CollidableDescription>(),
        24usize,
        concat!("Size of: ", stringify!(Bepu_CollidableDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_CollidableDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_CollidableDescription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Shape) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CollidableDescription),
            "::",
            stringify!(Shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Continuity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CollidableDescription),
            "::",
            stringify!(Continuity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumSpeculativeMargin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CollidableDescription),
            "::",
            stringify!(MinimumSpeculativeMargin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumSpeculativeMargin) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CollidableDescription),
            "::",
            stringify!(MaximumSpeculativeMargin)
        )
    );
}
#[doc = " <summary>\n Describes the thresholds for a body going to sleep.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyActivityDescription {
    #[doc = " <summary>\n Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity).\n </summary>"]
    pub SleepThreshold: f32,
    #[doc = " <summary>\n The number of time steps that the body must be under the sleep threshold before the body becomes a sleep candidate.\n Note that the body is not guaranteed to go to sleep immediately after meeting this minimum.\n </summary>"]
    pub MinimumTimestepCountUnderThreshold: u8,
}
#[test]
fn bindgen_test_layout_Bepu_BodyActivityDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyActivityDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyActivityDescription>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_BodyActivityDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyActivityDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyActivityDescription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SleepThreshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyActivityDescription),
            "::",
            stringify!(SleepThreshold)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).MinimumTimestepCountUnderThreshold) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyActivityDescription),
            "::",
            stringify!(MinimumTimestepCountUnderThreshold)
        )
    );
}
#[doc = " <summary>\n Describes a body's state.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyDescription {
    #[doc = " <summary>\n Position and orientation of the body.\n </summary>"]
    pub Pose: Bepu_RigidPose,
    #[doc = " <summary>\n Linear and angular velocity of the body.\n </summary>"]
    pub Velocity: Bepu_BodyVelocity,
    #[doc = " <summary>\n Mass and inertia tensor of the body.\n </summary>"]
    pub LocalInertia: Bepu_BodyInertia,
    #[doc = " <summary>\n Shape and collision detection settings for the body.\n </summary>"]
    pub Collidable: Bepu_CollidableDescription,
    #[doc = " <summary>\n Sleeping settings for the body.\n </summary>"]
    pub Activity: Bepu_BodyActivityDescription,
}
#[test]
fn bindgen_test_layout_Bepu_BodyDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyDescription> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyDescription>(),
        128usize,
        concat!("Size of: ", stringify!(Bepu_BodyDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyDescription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyDescription),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Velocity) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyDescription),
            "::",
            stringify!(Velocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalInertia) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyDescription),
            "::",
            stringify!(LocalInertia)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Collidable) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyDescription),
            "::",
            stringify!(Collidable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Activity) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyDescription),
            "::",
            stringify!(Activity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyConstraintReference {
    pub ConnectingConstraintHandle: Bepu_ConstraintHandle,
    pub BodyIndexInConstraint: i32,
}
#[test]
fn bindgen_test_layout_Bepu_BodyConstraintReference() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyConstraintReference> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyConstraintReference>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_BodyConstraintReference))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyConstraintReference>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyConstraintReference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectingConstraintHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyConstraintReference),
            "::",
            stringify!(ConnectingConstraintHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BodyIndexInConstraint) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyConstraintReference),
            "::",
            stringify!(BodyIndexInConstraint)
        )
    );
}
#[doc = " <summary>\n Describes the properties of a static object. When added to a simulation, static objects can collide but have no velocity and will not move in response to forces.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_StaticDescription {
    #[doc = " <summary>\n Position and orientation of the static.\n </summary>"]
    pub Pose: Bepu_RigidPose,
    #[doc = " <summary>\n Shape of the static.\n </summary>"]
    pub Shape: Bepu_TypedIndex,
    #[doc = " <summary>\n Continuous collision detection settings for the static.\n </summary>"]
    pub Continuity: Bepu_ContinuousDetection,
}
#[test]
fn bindgen_test_layout_Bepu_StaticDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_StaticDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_StaticDescription>(),
        48usize,
        concat!("Size of: ", stringify!(Bepu_StaticDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_StaticDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_StaticDescription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_StaticDescription),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Shape) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_StaticDescription),
            "::",
            stringify!(Shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Continuity) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_StaticDescription),
            "::",
            stringify!(Continuity)
        )
    );
}
#[doc = " <summary>\n Stores data for a static collidable in the simulation. Statics can be posed and collide, but have no velocity and no dynamic behavior.\n </summary>\n <remarks>Unlike bodies, statics have a very simple access pattern. Most data is referenced together and there are no extreme high frequency data accesses like there are in the solver.\n Everything can be conveniently stored within a single location contiguously.</remarks>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Static {
    #[doc = " <summary>\n Pose of the static collidable.\n </summary>"]
    pub Pose: Bepu_RigidPose,
    #[doc = " <summary>\n Continuous collision detection settings for this collidable. Includes the collision detection mode to use and tuning variables associated with those modes.\n </summary>\n <remarks>Note that statics cannot move, so there is no difference between <see cref=\"ContinuousDetectionMode.Discrete\"/> and <see cref=\"ContinuousDetectionMode.Passive\"/> for them.\n Enabling <see cref=\"ContinuousDetectionMode.Continuous\"/> will still require that pairs associated with the static use swept continuous collision detection.</remarks>"]
    pub Continuity: Bepu_ContinuousDetection,
    #[doc = " <summary>\n Index of the shape used by the static. While this can be changed, any transition from shapeless->shapeful or shapeful->shapeless must be reported to the broad phase.\n If you need to perform such a transition, consider using <see cref=\"Statics.SetShape\"/> or Statics.ApplyDescription; those functions update the relevant state.\n </summary>"]
    pub Shape: Bepu_TypedIndex,
    #[doc = " <summary>\n Index of the collidable in the broad phase. Used to look up the target location for bounding box scatters. Under normal circumstances, this should not be set externally.\n </summary>"]
    pub BroadPhaseIndex: i32,
}
#[test]
fn bindgen_test_layout_Bepu_Static() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Static> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Static>(),
        52usize,
        concat!("Size of: ", stringify!(Bepu_Static))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Static>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Static))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Static),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Continuity) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Static),
            "::",
            stringify!(Continuity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Shape) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Static),
            "::",
            stringify!(Shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BroadPhaseIndex) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Static),
            "::",
            stringify!(BroadPhaseIndex)
        )
    );
}
pub const Bepu_BPI: f32 = 3.1415927410125732;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_SpringSettings {
    #[doc = " <summary>\n Target number of undamped oscillations per unit of time, scaled by 2 * PI.\n </summary>"]
    pub AngularFrequency: f32,
    #[doc = " <summary>\n Twice the ratio of the spring's actual damping to its critical damping.\n </summary>"]
    pub TwiceDampingRatio: f32,
}
#[test]
fn bindgen_test_layout_Bepu_SpringSettings() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_SpringSettings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_SpringSettings>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_SpringSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_SpringSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_SpringSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AngularFrequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SpringSettings),
            "::",
            stringify!(AngularFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TwiceDampingRatio) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SpringSettings),
            "::",
            stringify!(TwiceDampingRatio)
        )
    );
}
#[doc = " <summary>\n Marks a collidable as owned by a dynamic body.\n </summary>"]
pub const Bepu_CollidableMobility_Dynamic: Bepu_CollidableMobility = 0;
#[doc = " <summary>\n Marks a collidable as owned by a kinematic body.\n </summary>"]
pub const Bepu_CollidableMobility_Kinematic: Bepu_CollidableMobility = 1;
#[doc = " <summary>\n Marks the collidable as an independent immobile collidable.\n </summary>"]
pub const Bepu_CollidableMobility_Static: Bepu_CollidableMobility = 2;
#[doc = " <summary>\n Represents how a collidable can interact and move.\n </summary>"]
pub type Bepu_CollidableMobility = u32;
#[doc = " <summary>\n Uses a bitpacked representation to refer to a body or static collidable.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_CollidableReference {
    #[doc = " <summary>\n Bitpacked representation of the collidable reference.\n </summary>"]
    pub Packed: u32,
}
#[test]
fn bindgen_test_layout_Bepu_CollidableReference() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_CollidableReference> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_CollidableReference>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_CollidableReference))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_CollidableReference>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_CollidableReference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Packed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CollidableReference),
            "::",
            stringify!(Packed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_CollidablePair {
    pub A: Bepu_CollidableReference,
    pub B: Bepu_CollidableReference,
}
#[test]
fn bindgen_test_layout_Bepu_CollidablePair() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_CollidablePair> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_CollidablePair>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_CollidablePair))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_CollidablePair>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_CollidablePair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CollidablePair),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CollidablePair),
            "::",
            stringify!(B)
        )
    );
}
#[doc = " <summary>\n Information about a single contact in a convex collidable pair. Convex collidable pairs share one surface basis across the manifold, since the contact surface is guaranteed to be a plane.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_ConvexContact {
    #[doc = " <summary>\n Offset from the position of collidable A to the contact position.\n </summary>"]
    pub Offset: Bepu_Vector3,
    #[doc = " <summary>\n Penetration depth between the two collidables at this contact. Negative values represent separation.\n </summary>"]
    pub Depth: f32,
    #[doc = " <summary>\n Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the\n same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame.\n </summary>"]
    pub FeatureId: i32,
}
#[test]
fn bindgen_test_layout_Bepu_ConvexContact() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_ConvexContact> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_ConvexContact>(),
        20usize,
        concat!("Size of: ", stringify!(Bepu_ConvexContact))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_ConvexContact>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_ConvexContact))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexContact),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexContact),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexContact),
            "::",
            stringify!(FeatureId)
        )
    );
}
#[doc = " <summary>\n Contains the data associated with a convex contact manifold.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_ConvexContactManifold {
    #[doc = " <summary>\n Offset from collidable A to collidable B.\n </summary>"]
    pub OffsetB: Bepu_Vector3,
    pub Count: i32,
    #[doc = " <summary>\n Surface normal shared by all contacts. Points from collidable B to collidable A.\n </summary>"]
    pub Normal: Bepu_Vector3,
    pub Contacts: [Bepu_ConvexContact; 4usize],
}
#[test]
fn bindgen_test_layout_Bepu_ConvexContactManifold() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_ConvexContactManifold> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_ConvexContactManifold>(),
        108usize,
        concat!("Size of: ", stringify!(Bepu_ConvexContactManifold))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_ConvexContactManifold>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_ConvexContactManifold))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetB) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexContactManifold),
            "::",
            stringify!(OffsetB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexContactManifold),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Normal) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexContactManifold),
            "::",
            stringify!(Normal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Contacts) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexContactManifold),
            "::",
            stringify!(Contacts)
        )
    );
}
#[doc = " <summary>\n Information about a single contact in a nonconvex collidable pair.\n Nonconvex pairs can have different surface bases at each contact point, since the contact surface is not guaranteed to be a plane.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_NonconvexContact {
    #[doc = " <summary>\n Offset from the position of collidable A to the contact position.\n </summary>"]
    pub Offset: Bepu_Vector3,
    #[doc = " <summary>\n Penetration depth between the two collidables at this contact. Negative values represent separation.\n </summary>"]
    pub Depth: f32,
    #[doc = " <summary>\n Surface basis of the contact. If transformed into a rotation matrix, X and Z represent tangent directions and Y represents the contact normal. Points from collidable B to collidable A.\n </summary>"]
    pub Normal: Bepu_Vector3,
    #[doc = " <summary>\n Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the\n same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame.\n </summary>"]
    pub FeatureId: i32,
}
#[test]
fn bindgen_test_layout_Bepu_NonconvexContact() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_NonconvexContact> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_NonconvexContact>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_NonconvexContact))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_NonconvexContact>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_NonconvexContact))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NonconvexContact),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NonconvexContact),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Normal) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NonconvexContact),
            "::",
            stringify!(Normal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureId) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NonconvexContact),
            "::",
            stringify!(FeatureId)
        )
    );
}
#[doc = " <summary>\n Contains the data associated with a nonconvex contact manifold.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_NonconvexContactManifold {
    #[doc = " <summary>\n Offset from collidable A to collidable B.\n </summary>"]
    pub OffsetB: Bepu_Vector3,
    pub Count: i32,
    pub Contacts: [Bepu_NonconvexContact; 4usize],
}
#[test]
fn bindgen_test_layout_Bepu_NonconvexContactManifold() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_NonconvexContactManifold> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_NonconvexContactManifold>(),
        144usize,
        concat!("Size of: ", stringify!(Bepu_NonconvexContactManifold))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_NonconvexContactManifold>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_NonconvexContactManifold))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetB) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NonconvexContactManifold),
            "::",
            stringify!(OffsetB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NonconvexContactManifold),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Contacts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NonconvexContactManifold),
            "::",
            stringify!(Contacts)
        )
    );
}
#[doc = " <summary>\n Material properties governing the interaction between colliding bodies. Used by the narrow phase to create constraints of the appropriate configuration.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_PairMaterialProperties {
    #[doc = " <summary>\n Coefficient of friction to apply for the constraint. Maximum friction force will be equal to the normal force times the friction coefficient.\n </summary>"]
    pub FrictionCoefficient: f32,
    #[doc = " <summary>\n Maximum relative velocity along the contact normal at which the collision constraint will recover from penetration. Clamps the velocity goal created from the spring settings.\n </summary>"]
    pub MaximumRecoveryVelocity: f32,
    #[doc = " <summary>\n Defines the constraint's penetration recovery spring properties.\n </summary>"]
    pub ContactSpringSettings: Bepu_SpringSettings,
}
#[test]
fn bindgen_test_layout_Bepu_PairMaterialProperties() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_PairMaterialProperties> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_PairMaterialProperties>(),
        16usize,
        concat!("Size of: ", stringify!(Bepu_PairMaterialProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_PairMaterialProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_PairMaterialProperties))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FrictionCoefficient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PairMaterialProperties),
            "::",
            stringify!(FrictionCoefficient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumRecoveryVelocity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PairMaterialProperties),
            "::",
            stringify!(MaximumRecoveryVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContactSpringSettings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PairMaterialProperties),
            "::",
            stringify!(ContactSpringSettings)
        )
    );
}
#[doc = " <summary>\n Defines the callbacks invoked during narrow phase collision detection execution.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_NarrowPhaseCallbacks {
    #[doc = " <summary>\n Called after the simulation is created. Can be null.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation owning these callbacks.</param>"]
    pub InitializeFunction:
        ::std::option::Option<unsafe extern "C" fn(simulationHandle: Bepu_SimulationHandle)>,
    #[doc = " <summary>\n Called when the simulation is being torn down. Can be null.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation owning these callbacks.</param>"]
    pub DisposeFunction:
        ::std::option::Option<unsafe extern "C" fn(simulationHandle: Bepu_SimulationHandle)>,
    #[doc = " <summary>\n Called for each pair of collidables with overlapping bounding boxes found by the broad phase.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation owning these callbacks.</param>\n <param name=\"workerIndex\">Index of the worker within the thread dispatcher that's running this callback.</param>\n <param name=\"a\">First collidable in the pair.</param>\n <param name=\"b\">Second collidable in the pair.</param>\n <param name=\"speculativeMargin\">Speculative contact margin for the pair. Calculated ahead of time, but can be overridden.</param>\n <returns>True if the collision detection should run for this pair, false otherwise.</returns>"]
    pub AllowContactGenerationFunction: ::std::option::Option<
        unsafe extern "C" fn(
            simulationHandle: Bepu_SimulationHandle,
            workerIndex: i32,
            a: Bepu_CollidableReference,
            b: Bepu_CollidableReference,
            speculativeMargin: *mut f32,
        ) -> bool,
    >,
    #[doc = " <summary>\n For pairs involving compound collidables (any type that has children, e.g. Compound, BigCompound, and Mesh), this is invoked for each pair of children with overlapping bounds.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation owning these callbacks.</param>\n <param name=\"workerIndex\">Index of the worker within the thread dispatcher that's running this callback.</param>\n <param name=\"collidablePair\">References to the parent collidables in this pair.</param>\n <param name=\"childIndexA\">Index of the child belonging to the first collidable in the pair.</param>\n <param name=\"childIndexB\">Index of the child belonging to the second collidable in the pair.</param>\n <returns>True if the collision detection should run for these children, false otherwise.</returns>"]
    pub AllowContactGenerationBetweenChildrenFunction: ::std::option::Option<
        unsafe extern "C" fn(
            simulationHandle: Bepu_SimulationHandle,
            workerIndex: i32,
            collidablePair: Bepu_CollidablePair,
            childIndexA: i32,
            childIndexB: i32,
        ) -> bool,
    >,
    #[doc = " <summary>\n Called after contacts have been found for a collidable pair that resulted in a convex manifold.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation owning these callbacks.</param>\n <param name=\"workerIndex\">Index of the worker within the thread dispatcher that's running this callback.</param>\n <param name=\"collidablePair\">References to the parent collidables in this pair.</param>\n <param name=\"contactManifold\">Contacts identified between the pair.</param>\n <param name=\"materialProperties\">Contact constraint material properties to use for the constraint, if any.</param>\n <returns>True if a contact constraint should be created for this contact manifold, false otherwise.</returns>"]
    pub ConfigureConvexContactManifoldFunction: ::std::option::Option<
        unsafe extern "C" fn(
            simulationHandle: Bepu_SimulationHandle,
            workerIndex: i32,
            collidablePair: Bepu_CollidablePair,
            contactManifold: *mut Bepu_ConvexContactManifold,
            materialProperties: *mut Bepu_PairMaterialProperties,
        ) -> bool,
    >,
    #[doc = " <summary>\n Called after contacts have been found for a collidable pair that resulted in a nonconvex manifold.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation owning these callbacks.</param>\n <param name=\"workerIndex\">Index of the worker within the thread dispatcher that's running this callback.</param>\n <param name=\"collidablePair\">References to the parent collidables in this pair.</param>\n <param name=\"contactManifold\">Contacts identified between the pair.</param>\n <param name=\"materialProperties\">Contact constraint material properties to use for the constraint, if any.</param>\n <returns>True if a contact constraint should be created for this contact manifold, false otherwise.</returns>"]
    pub ConfigureNonconvexContactManifoldFunction: ::std::option::Option<
        unsafe extern "C" fn(
            simulationHandle: Bepu_SimulationHandle,
            workerIndex: i32,
            collidablePair: Bepu_CollidablePair,
            contactManifold: *mut Bepu_NonconvexContactManifold,
            materialProperties: *mut Bepu_PairMaterialProperties,
        ) -> bool,
    >,
    #[doc = " <summary>\n Called for contacts identified between children in a compound-involving pair prior to being processed into the top level contact manifold.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation owning these callbacks.</param>\n <param name=\"workerIndex\">Index of the worker within the thread dispatcher that's running this callback.</param>\n <param name=\"collidablePair\">References to the parent collidables in this pair.</param>\n <param name=\"childIndexA\">Index of the child belonging to the first collidable in the pair.</param>\n <param name=\"childIndexB\">Index of the child belonging to the second collidable in the pair.</param>\n <param name=\"contactManifold\">Contacts identified between the pair.</param>\n <returns>True if the contacts in this child pair should be considered for constraint generation, false otherwise.</returns>\n <remarks>Note that all children are required to be convex, so there is no nonconvex version of this callback.</remarks>"]
    pub ConfigureChildContactManifoldFunction: ::std::option::Option<
        unsafe extern "C" fn(
            simulationHandle: Bepu_SimulationHandle,
            workerIndex: i32,
            collidablePair: Bepu_CollidablePair,
            childIndexA: i32,
            childIndexB: i32,
            contactManifold: *mut Bepu_ConvexContactManifold,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_Bepu_NarrowPhaseCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_NarrowPhaseCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_NarrowPhaseCallbacks>(),
        56usize,
        concat!("Size of: ", stringify!(Bepu_NarrowPhaseCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_NarrowPhaseCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_NarrowPhaseCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InitializeFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NarrowPhaseCallbacks),
            "::",
            stringify!(InitializeFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisposeFunction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NarrowPhaseCallbacks),
            "::",
            stringify!(DisposeFunction)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).AllowContactGenerationFunction) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NarrowPhaseCallbacks),
            "::",
            stringify!(AllowContactGenerationFunction)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).AllowContactGenerationBetweenChildrenFunction) as usize
                - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NarrowPhaseCallbacks),
            "::",
            stringify!(AllowContactGenerationBetweenChildrenFunction)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConfigureConvexContactManifoldFunction) as usize
                - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NarrowPhaseCallbacks),
            "::",
            stringify!(ConfigureConvexContactManifoldFunction)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConfigureNonconvexContactManifoldFunction) as usize
                - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NarrowPhaseCallbacks),
            "::",
            stringify!(ConfigureNonconvexContactManifoldFunction)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConfigureChildContactManifoldFunction) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NarrowPhaseCallbacks),
            "::",
            stringify!(ConfigureChildContactManifoldFunction)
        )
    );
}
#[doc = " <summary>\n Angular velocity is directly integrated and does not change as the body pose changes. Does not conserve angular momentum.\n </summary>"]
pub const Bepu_AngularIntegrationMode_Nonconserving: Bepu_AngularIntegrationMode = 0;
#[doc = " <summary>\n Approximately conserves angular momentum by updating the angular velocity according to the change in orientation. Does a decent job for gyroscopes, but angular velocities will tend to drift towards a minimal inertia axis.\n </summary>"]
pub const Bepu_AngularIntegrationMode_ConserveMomentum: Bepu_AngularIntegrationMode = 1;
#[doc = " <summary>\n Approximately conserves angular momentum by including an implicit gyroscopic torque. Best option for Dzhanibekov effect simulation, but applies a damping effect that can make gyroscopes less useful.\n </summary>"]
pub const Bepu_AngularIntegrationMode_ConserveMomentumWithGyroscopicTorque:
    Bepu_AngularIntegrationMode = 2;
#[doc = " <summary>\n Defines how a pose integrator should handle angular velocity integration.\n </summary>"]
pub type Bepu_AngularIntegrationMode = ::std::os::raw::c_int;
#[doc = " <summary>\n Defines pose integrator state and callbacks.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_PoseIntegratorCallbacks {
    #[doc = " <summary>\n How the pose integrator should handle angular velocity integration.\n </summary>"]
    pub AngularIntegrationMode: Bepu_AngularIntegrationMode,
    #[doc = " <summary>\n Whether the integrator should use only one step for unconstrained bodies when using a substepping solver.\n If true, unconstrained bodies use a single step of length equal to the dt provided to <see cref=\"Simulation.Timestep\"/>.\n If false, unconstrained bodies will be integrated with the same number of substeps as the constrained bodies in the solver.\n </summary>"]
    pub AllowSubstepsForUnconstrainedBodies: bool,
    #[doc = " <summary>\n Whether the velocity integration callback should be called for kinematic bodies.\n If true, <see cref=\"IntegrateVelocity\"/> will be called for bundles including kinematic bodies.\n If false, kinematic bodies will just continue using whatever velocity they have set.\n Most use cases should set this to false.\n </summary>"]
    pub IntegrateVelocityForKinematics: bool,
    #[doc = " <summary>\n Whether to use a scalar or vectorized integrator callback. If true, <see cref=\"IntegrateVelocityScalar\"/> will be used.\n The scalar callback has much higher overhead due to the required data transpositions.\n If false, <see cref=\"IntegrateVelocitySIMD128\"/> or <see cref=\"IntegrateVelocitySIMD256\"/> will be called.\n Use <see cref=\"GetSIMDWidth\"/> to know which vectorized callback would be invoked.\n </summary>"]
    pub UseScalarCallback: bool,
    #[doc = " <summary>\n Called after the simulation is created.\n </summary>\n <param name=\"simulation\">Simulation to which these callbacks belong.</param>"]
    pub Initialize: ::std::option::Option<unsafe extern "C" fn(simulation: Bepu_SimulationHandle)>,
    #[doc = " <summary>\n Called before each simulation stage which could execute velocity integration.\n </summary>\n <param name=\"simulation\">Simulation to which these callbacks belong.</param>\n <param name=\"dt\">Timestep duration that subsequent velocity integrations will be invoked with.</param>"]
    pub PrepareForIntegration:
        ::std::option::Option<unsafe extern "C" fn(simulation: Bepu_SimulationHandle, dt: f32)>,
    #[doc = " <summary>\n Called for every active body during each integration pass when <see cref=\"UseScalarCallback\"/> is true.\n </summary>\n <param name=\"simulation\">Simulation to which these callbacks belong.</param>\n <param name=\"bodyIndex\">Current index of the body being integrated in the active body set. This is distinct from the <see cref=\"BodyHandle\"/>; the body index can change over time.</param>\n <param name=\"position\">Current position of the body.</param>\n <param name=\"orientation\">Current orientation of the body.</param>\n <param name=\"localInertia\">Inertia properties of the body in its local space.</param>\n <param name=\"workerIndex\">Index of the thread worker processing this callback.</param>\n <param name=\"dt\">Timestep duration that subsequent velocity integrations will be invoked with.</param>\n <param name=\"velocity\">Velocity of the body to be updated by this callback.</param>"]
    pub IntegrateVelocityScalar: ::std::option::Option<
        unsafe extern "C" fn(
            simulation: Bepu_SimulationHandle,
            bodyIndex: i32,
            position: Bepu_Vector3,
            orientation: Bepu_Quaternion,
            localInertia: Bepu_BodyInertia,
            workerIndex: i32,
            dt: f32,
            velocity: *mut Bepu_BodyVelocity,
        ),
    >,
    #[doc = " <summary>\n Called for every active body bundle during each integration pass when <see cref=\"UseScalarCallback\"/> is false and SIMD width is 128.\n </summary>\n <param name=\"simulation\">Simulation to which these callbacks belong.</param>\n <param name=\"bodyIndices\">Current indices of the body bundle being integrated in the active body set. This is distinct from the <see cref=\"BodyHandle\"/>; the body index can change over time.</param>\n <param name=\"position\">Current positions of the body bundle.</param>\n <param name=\"orientation\">Current orientations of the body bundle.</param>\n <param name=\"localInertia\">Inertia properties of the body bundle in their local space.</param>\n <param name=\"workerIndex\">Index of the thread worker processing this callback.</param>\n <param name=\"dt\">Timestep duration that subsequent velocity integrations will be invoked with.</param>\n <param name=\"velocity\">Velocity of the body bundle to be updated by this callback.</param>"]
    pub IntegrateVelocitySIMD128: ::std::option::Option<
        unsafe extern "C" fn(
            simulation: Bepu_SimulationHandle,
            bodyIndices: Bepu_Vector128I,
            positions: *mut Bepu_Vector3SIMD128,
            orientations: *mut Bepu_QuaternionSIMD128,
            localInertias: *mut Bepu_BodyInertiaSIMD128,
            integrationMask: Bepu_Vector128I,
            workerIndex: i32,
            dt: Bepu_Vector128F,
            bodyVelocities: *mut Bepu_BodyVelocitySIMD128,
        ),
    >,
    #[doc = " <summary>\n Called for every active body bundle during each integration pass when <see cref=\"UseScalarCallback\"/> is false and SIMD width is 256.\n </summary>\n <param name=\"simulation\">Simulation to which these callbacks belong.</param>\n <param name=\"bodyIndices\">Current indices of the body bundle being integrated in the active body set. This is distinct from the <see cref=\"BodyHandle\"/>; the body index can change over time.</param>\n <param name=\"position\">Current positions of the body bundle.</param>\n <param name=\"orientation\">Current orientations of the body bundle.</param>\n <param name=\"localInertia\">Inertia properties of the body bundle in their local space.</param>\n <param name=\"workerIndex\">Index of the thread worker processing this callback.</param>\n <param name=\"dt\">Timestep duration that subsequent velocity integrations will be invoked with.</param>\n <param name=\"velocity\">Velocity of the body bundle to be updated by this callback.</param>"]
    pub IntegrateVelocitySIMD256: ::std::option::Option<
        unsafe extern "C" fn(
            simulation: Bepu_SimulationHandle,
            bodyIndices: Bepu_Vector256I,
            positions: *mut Bepu_Vector3SIMD256,
            orientations: *mut Bepu_QuaternionSIMD256,
            localInertias: *mut Bepu_BodyInertiaSIMD256,
            integrationMask: Bepu_Vector256I,
            workerIndex: i32,
            dt: Bepu_Vector256F,
            bodyVelocities: *mut Bepu_BodyVelocitySIMD256,
        ),
    >,
}
#[test]
fn bindgen_test_layout_Bepu_PoseIntegratorCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_PoseIntegratorCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_PoseIntegratorCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(Bepu_PoseIntegratorCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_PoseIntegratorCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_PoseIntegratorCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AngularIntegrationMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(AngularIntegrationMode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).AllowSubstepsForUnconstrainedBodies) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(AllowSubstepsForUnconstrainedBodies)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IntegrateVelocityForKinematics) as usize - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(IntegrateVelocityForKinematics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UseScalarCallback) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(UseScalarCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Initialize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(Initialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrepareForIntegration) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(PrepareForIntegration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntegrateVelocityScalar) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(IntegrateVelocityScalar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntegrateVelocitySIMD128) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(IntegrateVelocitySIMD128)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntegrateVelocitySIMD256) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_PoseIntegratorCallbacks),
            "::",
            stringify!(IntegrateVelocitySIMD256)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_ByteBuffer {
    #[doc = " <summary>\n Pointer to the beginning of the memory backing this buffer.\n </summary>"]
    pub Memory: *mut u8,
    #[doc = " <summary>\n Length of the buffer in bytes.\n </summary>"]
    pub Length: i32,
    #[doc = " <summary>\n Implementation specific identifier of the raw buffer set by its source. If taken from a BufferPool, Id includes the index in the power pool from which it was taken.\n </summary>"]
    pub Id: i32,
}
#[test]
fn bindgen_test_layout_Bepu_ByteBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_ByteBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_ByteBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(Bepu_ByteBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_ByteBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_ByteBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Memory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ByteBuffer),
            "::",
            stringify!(Memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ByteBuffer),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ByteBuffer),
            "::",
            stringify!(Id)
        )
    );
}
#[doc = " <summary>\n Span over an unmanaged memory region.\n </summary>\n <typeparam name=\"T\">Type of the memory exposed by the span.</typeparam>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Buffer<T> {
    #[doc = " <summary>\n Pointer to the beginning of the memory backing this buffer.\n </summary>"]
    pub Memory: *mut T,
    #[doc = " <summary>\n Length of the buffer in typed elements.\n </summary>"]
    pub Length: i32,
    #[doc = " <summary>\n Implementation specific identifier of the raw buffer set by its source. If taken from a BufferPool, Id includes the index in the power pool from which it was taken.\n </summary>"]
    pub Id: i32,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_QuickList<T> {
    #[doc = " <summary>\n Backing memory containing the elements of the list.\n Indices from 0 to Count-1 hold actual data. All other data is undefined.\n </summary>"]
    pub Span: Bepu_Buffer<T>,
    #[doc = " <summary>\n Number of elements in the list.\n </summary>"]
    pub Count: i32,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_NodeChild {
    pub Min: Bepu_Vector3,
    pub Index: i32,
    pub Max: Bepu_Vector3,
    pub LeafCount: i32,
}
#[test]
fn bindgen_test_layout_Bepu_NodeChild() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_NodeChild> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_NodeChild>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_NodeChild))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_NodeChild>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_NodeChild))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NodeChild),
            "::",
            stringify!(Min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NodeChild),
            "::",
            stringify!(Index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NodeChild),
            "::",
            stringify!(Max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeafCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_NodeChild),
            "::",
            stringify!(LeafCount)
        )
    );
}
#[doc = " <summary>\n 2-wide tree node.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Node {
    pub A: Bepu_NodeChild,
    pub B: Bepu_NodeChild,
}
#[test]
fn bindgen_test_layout_Bepu_Node() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Node>(),
        64usize,
        concat!("Size of: ", stringify!(Bepu_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Node>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Node),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Node),
            "::",
            stringify!(B)
        )
    );
}
#[doc = " <summary>\n Metadata associated with a 2-child tree node.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Metanode {
    pub Parent: i32,
    pub IndexInParent: i32,
    pub PackedFlagAndCostChange: i32,
}
#[test]
fn bindgen_test_layout_Bepu_Metanode() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Metanode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Metanode>(),
        12usize,
        concat!("Size of: ", stringify!(Bepu_Metanode))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Metanode>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Metanode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Metanode),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexInParent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Metanode),
            "::",
            stringify!(IndexInParent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PackedFlagAndCostChange) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Metanode),
            "::",
            stringify!(PackedFlagAndCostChange)
        )
    );
}
#[doc = " <summary>\n Pointer to a leaf's tree location.\n </summary>\n <remarks>The identity of a leaf is implicit in its position within the leaf array.</remarks>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Leaf {
    pub packed: u32,
}
#[test]
fn bindgen_test_layout_Bepu_Leaf() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Leaf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Leaf>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_Leaf))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Leaf>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Leaf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Leaf),
            "::",
            stringify!(packed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Tree {
    #[doc = " <summary>\n Buffer of nodes in the tree.\n </summary>"]
    pub Nodes: Bepu_Buffer<Bepu_Node>,
    #[doc = " <summary>\n Buffer of metanodes in the tree. Metanodes contain metadata that aren't read during most query operations but are useful for bookkeeping.\n </summary>"]
    pub Metanodes: Bepu_Buffer<Bepu_Metanode>,
    #[doc = " <summary>\n Buffer of leaves in the tree.\n </summary>"]
    pub Leaves: Bepu_Buffer<Bepu_Leaf>,
    #[doc = " <summary>\n Number of nodes in the tree.\n </summary>"]
    pub NodeCount: ::std::os::raw::c_int,
    #[doc = " <summary>\n Number of leaves in the tree.\n </summary>"]
    pub LeafCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Bepu_Tree() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Tree> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Tree>(),
        56usize,
        concat!("Size of: ", stringify!(Bepu_Tree))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Tree>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_Tree))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nodes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Tree),
            "::",
            stringify!(Nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Metanodes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Tree),
            "::",
            stringify!(Metanodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Leaves) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Tree),
            "::",
            stringify!(Leaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NodeCount) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Tree),
            "::",
            stringify!(NodeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeafCount) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Tree),
            "::",
            stringify!(LeafCount)
        )
    );
}
pub const Bepu_ShapeTypes_Sphere: Bepu_ShapeTypes = 0;
pub const Bepu_ShapeTypes_Capsule: Bepu_ShapeTypes = 1;
pub const Bepu_ShapeTypes_Box: Bepu_ShapeTypes = 2;
pub const Bepu_ShapeTypes_Triangle: Bepu_ShapeTypes = 3;
pub const Bepu_ShapeTypes_Cylinder: Bepu_ShapeTypes = 4;
pub const Bepu_ShapeTypes_ConvexHull: Bepu_ShapeTypes = 5;
pub const Bepu_ShapeTypes_Compound: Bepu_ShapeTypes = 6;
pub const Bepu_ShapeTypes_BigCompound: Bepu_ShapeTypes = 7;
pub const Bepu_ShapeTypes_Mesh: Bepu_ShapeTypes = 8;
pub type Bepu_ShapeTypes = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Sphere {
    #[doc = " <summary>\n Radius of the sphere.\n </summary>"]
    pub Radius: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Sphere() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Sphere> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Sphere>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_Sphere))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Sphere>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Sphere))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Radius) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Sphere),
            "::",
            stringify!(Radius)
        )
    );
}
#[doc = " <summary>\n Collision shape representing a sphere-expanded line segment.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Capsule {
    #[doc = " <summary>\n Spherical expansion applied to the internal line segment.\n </summary>"]
    pub Radius: f32,
    #[doc = " <summary>\n Half of the length of the internal line segment. Oriented along the local Y axis.\n </summary>"]
    pub HalfLength: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Capsule() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Capsule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Capsule>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_Capsule))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Capsule>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Capsule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Radius) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Capsule),
            "::",
            stringify!(Radius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HalfLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Capsule),
            "::",
            stringify!(HalfLength)
        )
    );
}
#[doc = " <summary>\n Collision shape representing a solid cuboid.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Box {
    #[doc = " <summary>\n Half of the box's width along its local X axis.\n </summary>"]
    pub HalfWidth: f32,
    #[doc = " <summary>\n Half of the box's height along its local Y axis.\n </summary>"]
    pub HalfHeight: f32,
    #[doc = " <summary>\n Half of the box's length along its local Z axis.\n </summary>"]
    pub HalfLength: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Box() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Box> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Box>(),
        12usize,
        concat!("Size of: ", stringify!(Bepu_Box))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Box>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Box))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HalfWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Box),
            "::",
            stringify!(HalfWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HalfHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Box),
            "::",
            stringify!(HalfHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HalfLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Box),
            "::",
            stringify!(HalfLength)
        )
    );
}
#[doc = " <summary>\n Collision shape representing an individual triangle. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Triangle {
    #[doc = " <summary>\n First vertex of the triangle in local space.\n </summary>"]
    pub A: Bepu_Vector3,
    #[doc = " <summary>\n Second vertex of the triangle in local space.\n </summary>"]
    pub B: Bepu_Vector3,
    #[doc = " <summary>\n Third vertex of the triangle in local space.\n </summary>"]
    pub C: Bepu_Vector3,
}
#[test]
fn bindgen_test_layout_Bepu_Triangle() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Triangle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Triangle>(),
        36usize,
        concat!("Size of: ", stringify!(Bepu_Triangle))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Triangle>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Triangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Triangle),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Triangle),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).C) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Triangle),
            "::",
            stringify!(C)
        )
    );
}
#[doc = " <summary>\n Collision shape representing a cylinder.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Cylinder {
    #[doc = " <summary>\n Radius of the cylinder.\n </summary>"]
    pub Radius: f32,
    #[doc = " <summary>\n Half length of the cylinder along its local Y axis.\n </summary>"]
    pub HalfLength: f32,
}
#[test]
fn bindgen_test_layout_Bepu_Cylinder() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Cylinder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Cylinder>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_Cylinder))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Cylinder>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_Cylinder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Radius) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Cylinder),
            "::",
            stringify!(Radius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HalfLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Cylinder),
            "::",
            stringify!(HalfLength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_HullVertexIndex {
    pub BundleIndex: u16,
    pub InnerIndex: u16,
}
#[test]
fn bindgen_test_layout_Bepu_HullVertexIndex() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_HullVertexIndex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_HullVertexIndex>(),
        4usize,
        concat!("Size of: ", stringify!(Bepu_HullVertexIndex))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_HullVertexIndex>(),
        2usize,
        concat!("Alignment of ", stringify!(Bepu_HullVertexIndex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BundleIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_HullVertexIndex),
            "::",
            stringify!(BundleIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InnerIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_HullVertexIndex),
            "::",
            stringify!(InnerIndex)
        )
    );
}
#[doc = " <summary>\n Dummy type standing in for the compile time variable width Vector3Wide type.\n Pointers to buffers of this type should be reinterpreted to either Vector3SIMD128 or Vector3SIMD256 depending on what SIMD width is in use.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Vector3Wide {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Bepu_Vector3Wide() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Vector3Wide>(),
        1usize,
        concat!("Size of: ", stringify!(Bepu_Vector3Wide))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Vector3Wide>(),
        1usize,
        concat!("Alignment of ", stringify!(Bepu_Vector3Wide))
    );
}
#[doc = " <summary>\n Dummy type standing in for the compile time variable width HullBoundingPlanes type.\n Pointers to buffers of this type should be reinterpreted to either HullBoundingPlanesSIMD128 or HullBoundingPlanesSIMD256 depending on what SIMD width is in use.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_HullBoundingPlanes {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Bepu_HullBoundingPlanes() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_HullBoundingPlanes>(),
        1usize,
        concat!("Size of: ", stringify!(Bepu_HullBoundingPlanes))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_HullBoundingPlanes>(),
        1usize,
        concat!("Alignment of ", stringify!(Bepu_HullBoundingPlanes))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_HullBoundingPlanesSIMD128 {
    pub Normal: Bepu_Vector3SIMD128,
    pub Offset: Bepu_Vector128F,
}
#[test]
fn bindgen_test_layout_Bepu_HullBoundingPlanesSIMD128() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_HullBoundingPlanesSIMD128> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_HullBoundingPlanesSIMD128>(),
        64usize,
        concat!("Size of: ", stringify!(Bepu_HullBoundingPlanesSIMD128))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_HullBoundingPlanesSIMD128>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_HullBoundingPlanesSIMD128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Normal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_HullBoundingPlanesSIMD128),
            "::",
            stringify!(Normal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_HullBoundingPlanesSIMD128),
            "::",
            stringify!(Offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_HullBoundingPlanesSIMD256 {
    pub Normal: Bepu_Vector3SIMD256,
    pub Offset: Bepu_Vector256F,
}
#[test]
fn bindgen_test_layout_Bepu_HullBoundingPlanesSIMD256() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_HullBoundingPlanesSIMD256> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_HullBoundingPlanesSIMD256>(),
        128usize,
        concat!("Size of: ", stringify!(Bepu_HullBoundingPlanesSIMD256))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_HullBoundingPlanesSIMD256>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_HullBoundingPlanesSIMD256))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Normal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_HullBoundingPlanesSIMD256),
            "::",
            stringify!(Normal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_HullBoundingPlanesSIMD256),
            "::",
            stringify!(Offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_ConvexHull {
    #[doc = " <summary>\n Bundled points of the convex hull.\n </summary>"]
    pub Points: Bepu_Buffer<Bepu_Vector3Wide>,
    #[doc = " <summary>\n Bundled bounding planes associated with the convex hull's faces.\n </summary>"]
    pub BoundingPlanes: Bepu_Buffer<Bepu_HullBoundingPlanes>,
    #[doc = " <summary>\n Combined set of vertices used by each face. Use FaceToVertexIndicesStart to index into this for a particular face. Indices stored in counterclockwise winding in right handed space, clockwise in left handed space.\n </summary>"]
    pub FaceVertexIndices: Bepu_Buffer<Bepu_HullVertexIndex>,
    #[doc = " <summary>\n Start indices of faces in the FaceVertexIndices.\n </summary>"]
    pub FaceToVertexIndicesStart: Bepu_Buffer<i32>,
}
#[test]
fn bindgen_test_layout_Bepu_ConvexHull() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_ConvexHull> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_ConvexHull>(),
        64usize,
        concat!("Size of: ", stringify!(Bepu_ConvexHull))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_ConvexHull>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_ConvexHull))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexHull),
            "::",
            stringify!(Points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BoundingPlanes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexHull),
            "::",
            stringify!(BoundingPlanes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FaceVertexIndices) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexHull),
            "::",
            stringify!(FaceVertexIndices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FaceToVertexIndicesStart) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_ConvexHull),
            "::",
            stringify!(FaceToVertexIndicesStart)
        )
    );
}
#[doc = " <summary>\n Shape and pose of a child within a compound shape.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_CompoundChild {
    #[doc = " <summary>\n Local orientation of the child in the compound.\n </summary>"]
    pub LocalOrientation: Bepu_Quaternion,
    #[doc = " <summary>\n Local position of the child in the compound.\n </summary>"]
    pub LocalPosition: Bepu_Vector3,
    #[doc = " <summary>\n Index of the shape within whatever shape collection holds the compound's child shape data.\n </summary>"]
    pub ShapeIndex: Bepu_TypedIndex,
}
#[test]
fn bindgen_test_layout_Bepu_CompoundChild() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_CompoundChild> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_CompoundChild>(),
        32usize,
        concat!("Size of: ", stringify!(Bepu_CompoundChild))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_CompoundChild>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_CompoundChild))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalOrientation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CompoundChild),
            "::",
            stringify!(LocalOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalPosition) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CompoundChild),
            "::",
            stringify!(LocalPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShapeIndex) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_CompoundChild),
            "::",
            stringify!(ShapeIndex)
        )
    );
}
#[doc = " <summary>\n Minimalist compound shape containing a list of child shapes. Does not make use of any internal acceleration structure; should be used only with small groups of shapes.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Compound {
    #[doc = " <summary>\n Buffer of children within this compound.\n </summary>"]
    pub Children: Bepu_Buffer<Bepu_CompoundChild>,
}
#[test]
fn bindgen_test_layout_Bepu_Compound() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Compound> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Compound>(),
        16usize,
        concat!("Size of: ", stringify!(Bepu_Compound))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Compound>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_Compound))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Children) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Compound),
            "::",
            stringify!(Children)
        )
    );
}
#[doc = " <summary>\n Compound shape containing a bunch of shapes accessible through a tree acceleration structure. Useful for compounds with lots of children.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BigCompound {
    #[doc = " <summary>\n Acceleration structure for the compound children.\n </summary>"]
    pub Tree: Bepu_Tree,
    #[doc = " <summary>\n Buffer of children within this compound.\n </summary>"]
    pub Children: Bepu_Buffer<Bepu_CompoundChild>,
}
#[test]
fn bindgen_test_layout_Bepu_BigCompound() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BigCompound> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BigCompound>(),
        72usize,
        concat!("Size of: ", stringify!(Bepu_BigCompound))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BigCompound>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_BigCompound))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Tree) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BigCompound),
            "::",
            stringify!(Tree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Children) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BigCompound),
            "::",
            stringify!(Children)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_Mesh {
    #[doc = " <summary>\n Acceleration structure of the mesh.\n </summary>"]
    pub Tree: Bepu_Tree,
    #[doc = " <summary>\n Buffer of triangles composing the mesh. Triangles will only collide with tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates.\n </summary>"]
    pub Triangles: Bepu_Buffer<Bepu_Triangle>,
    pub Scale: Bepu_Vector3,
    pub InverseScale: Bepu_Vector3,
}
#[test]
fn bindgen_test_layout_Bepu_Mesh() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_Mesh> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_Mesh>(),
        96usize,
        concat!("Size of: ", stringify!(Bepu_Mesh))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Mesh>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_Mesh))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Tree) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Mesh),
            "::",
            stringify!(Tree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Triangles) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Mesh),
            "::",
            stringify!(Triangles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Scale) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Mesh),
            "::",
            stringify!(Scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InverseScale) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_Mesh),
            "::",
            stringify!(InverseScale)
        )
    );
}
pub const Bepu_SIMDWidth_SIMD128: Bepu_SIMDWidth = 0;
pub const Bepu_SIMDWidth_SIMD256: Bepu_SIMDWidth = 1;
pub const Bepu_SIMDWidth_SIMD512: Bepu_SIMDWidth = 2;
pub type Bepu_SIMDWidth = ::std::os::raw::c_uint;
#[doc = " <summary>\n Defines properties of the solver\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_SolveDescription {
    #[doc = " <summary>\n Number of velocity iterations to use in the solver if there is no <see cref=\"VelocityIterationScheduler\"/> or if it returns a non-positive value for a substep.\n </summary>"]
    pub VelocityIterationCount: i32,
    #[doc = " <summary>\n Number of substeps to execute each time the solver runs.\n </summary>"]
    pub SubstepCount: i32,
    #[doc = " <summary>\n Number of synchronzed constraint batches to use before using a fallback approach.\n </summary>"]
    pub FallbackBatchThreshold: i32,
    #[doc = " <summary>\n Callback executed to determine how many velocity iterations should be used for a given substep. If null, or if it returns a non-positive value, the <see cref=\"VelocityIterationCount\"/> will be used instead.\n </summary>\n <param name=\"substepIndex\">Index of the substep to schedule velocity iterations for.</param>\n <returns>Number of velocity iterations to run during this substep.</returns>"]
    pub VelocityIterationScheduler:
        ::std::option::Option<unsafe extern "C" fn(substepIndex: i32) -> i32>,
}
#[test]
fn bindgen_test_layout_Bepu_SolveDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_SolveDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_SolveDescription>(),
        24usize,
        concat!("Size of: ", stringify!(Bepu_SolveDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_SolveDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_SolveDescription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VelocityIterationCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SolveDescription),
            "::",
            stringify!(VelocityIterationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubstepCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SolveDescription),
            "::",
            stringify!(SubstepCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FallbackBatchThreshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SolveDescription),
            "::",
            stringify!(FallbackBatchThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VelocityIterationScheduler) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SolveDescription),
            "::",
            stringify!(VelocityIterationScheduler)
        )
    );
}
#[doc = " <summary>\n The common set of allocation sizes for a simulation.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_SimulationAllocationSizes {
    #[doc = " <summary>\n The number of bodies to allocate space for.\n </summary>"]
    pub Bodies: i32,
    #[doc = " <summary>\n The number of statics to allocate space for.\n </summary>"]
    pub Statics: i32,
    #[doc = " <summary>\n The number of inactive islands to allocate space for.\n </summary>"]
    pub Islands: i32,
    #[doc = " <summary>\n Minimum number of shapes to allocate space for in each shape type batch.\n </summary>"]
    pub ShapesPerType: i32,
    #[doc = " <summary>\n The number of constraints to allocate bookkeeping space for. This does not affect actual type batch allocation sizes, only the solver-level constraint handle storage.\n </summary>"]
    pub Constraints: i32,
    #[doc = " <summary>\n The minimum number of constraints to allocate space for in each individual type batch.\n New type batches will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.\n The number of constraints can vary greatly across types- there are usually far more contacts than ragdoll constraints.\n Per type estimates can be assigned within the Solver.TypeBatchAllocation if necessary. This value acts as a lower bound for all types.\n </summary>"]
    pub ConstraintsPerTypeBatch: i32,
    #[doc = " <summary>\n The minimum number of constraints to allocate space for in each body's constraint list.\n New bodies will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it.\n </summary>"]
    pub ConstraintCountPerBodyEstimate: i32,
}
#[test]
fn bindgen_test_layout_Bepu_SimulationAllocationSizes() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_SimulationAllocationSizes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_SimulationAllocationSizes>(),
        28usize,
        concat!("Size of: ", stringify!(Bepu_SimulationAllocationSizes))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_SimulationAllocationSizes>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_SimulationAllocationSizes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bodies) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SimulationAllocationSizes),
            "::",
            stringify!(Bodies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Statics) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SimulationAllocationSizes),
            "::",
            stringify!(Statics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Islands) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SimulationAllocationSizes),
            "::",
            stringify!(Islands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShapesPerType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SimulationAllocationSizes),
            "::",
            stringify!(ShapesPerType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Constraints) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SimulationAllocationSizes),
            "::",
            stringify!(Constraints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConstraintsPerTypeBatch) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SimulationAllocationSizes),
            "::",
            stringify!(ConstraintsPerTypeBatch)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConstraintCountPerBodyEstimate) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_SimulationAllocationSizes),
            "::",
            stringify!(ConstraintCountPerBodyEstimate)
        )
    );
}
#[doc = " <summary>\n Location of a body in memory.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodyMemoryLocation {
    #[doc = " <summary>\n Index of the set owning the body reference. If the set index is 0, the body is awake. If the set index is greater than zero, the body is asleep.\n </summary>"]
    pub SetIndex: i32,
    #[doc = " <summary>\n Index of the body within its owning set.\n </summary>"]
    pub Index: i32,
}
#[test]
fn bindgen_test_layout_Bepu_BodyMemoryLocation() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodyMemoryLocation> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodyMemoryLocation>(),
        8usize,
        concat!("Size of: ", stringify!(Bepu_BodyMemoryLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodyMemoryLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(Bepu_BodyMemoryLocation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyMemoryLocation),
            "::",
            stringify!(SetIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodyMemoryLocation),
            "::",
            stringify!(Index)
        )
    );
}
#[doc = " <summary>\n Stores a group of bodies- either the set of active bodies, or the bodies involved in an inactive simulation island.\n </summary>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_BodySet {
    #[doc = " <summary>\n Remaps a body index to its handle.\n </summary>"]
    pub IndexToHandle: Bepu_Buffer<Bepu_BodyHandle>,
    #[doc = " <summary>\n Stores all data involved in solving constraints for a body, including pose, velocity, and inertia.\n </summary>"]
    pub DynamicsState: Bepu_Buffer<Bepu_BodyDynamics>,
    #[doc = " <summary>\n The collidables owned by each body in the set. Speculative margins, continuity settings, and shape indices can be changed directly.\n Shape indices cannot transition between pointing at a shape and pointing at nothing or vice versa without notifying the broad phase of the collidable addition or removal.\n </summary>"]
    pub Collidables: Bepu_Buffer<Bepu_Collidable>,
    #[doc = " <summary>\n Activity states of bodies in the set.\n </summary>"]
    pub Activity: Bepu_Buffer<Bepu_BodyActivity>,
    #[doc = " <summary>\n List of constraints associated with each body in the set.\n </summary>"]
    pub Constraints: Bepu_Buffer<Bepu_QuickList<Bepu_BodyConstraintReference>>,
    #[doc = " <summary>\n Number of bodies in the body set.\n </summary>"]
    pub Count: i32,
}
#[test]
fn bindgen_test_layout_Bepu_BodySet() {
    const UNINIT: ::std::mem::MaybeUninit<Bepu_BodySet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bepu_BodySet>(),
        88usize,
        concat!("Size of: ", stringify!(Bepu_BodySet))
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_BodySet>(),
        8usize,
        concat!("Alignment of ", stringify!(Bepu_BodySet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexToHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodySet),
            "::",
            stringify!(IndexToHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DynamicsState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodySet),
            "::",
            stringify!(DynamicsState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Collidables) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodySet),
            "::",
            stringify!(Collidables)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Activity) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodySet),
            "::",
            stringify!(Activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Constraints) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodySet),
            "::",
            stringify!(Constraints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Bepu_BodySet),
            "::",
            stringify!(Count)
        )
    );
}
extern "C" {
    #[doc = " <summary>\n Initializes the interop structures.\n </summary>"]
    #[link_name = "\u{1}_Initialize"]
    pub fn Bepu_Initialize();
}
extern "C" {
    #[doc = " <summary>\n Destroys all resources created through the interop API and releases interop structures.\n </summary>"]
    #[link_name = "\u{1}_Destroy"]
    pub fn Bepu_Destroy();
}
extern "C" {
    #[link_name = "\u{1}_GetSIMDWidth"]
    pub fn Bepu_GetSIMDWidth() -> Bepu_SIMDWidth;
}
extern "C" {
    #[doc = " <summary>\n Gets the number of threads exposed by the operating system on this platform. Cores with SMT can show as having multiple threads.\n </summary>\n <returns>Number of threads exposed by the operating system on this platform.</returns>"]
    #[link_name = "\u{1}_GetPlatformThreadCount"]
    pub fn Bepu_GetPlatformThreadCount() -> i32;
}
extern "C" {
    #[doc = " <summary>\n Creates a new buffer pool.\n </summary>\n <param name=\"minimumBlockAllocationSize\">Minimum size of individual block allocations. Must be a power of 2.\n Pools with single allocations larger than the minimum will use the minimum value necessary to hold one element.\n Buffers will be suballocated from blocks.</param>\n <param name=\"expectedUsedSlotCountPerPool\">Number of suballocations to preallocate reference space for.\n This does not preallocate actual blocks, just the space to hold references that are waiting in the pool.</param>"]
    #[link_name = "\u{1}_CreateBufferPool"]
    pub fn Bepu_CreateBufferPool(
        minimumBlockAllocationSize: i32,
        expectedUsedSlotCountPerPool: i32,
    ) -> Bepu_BufferPoolHandle;
}
extern "C" {
    #[doc = " <summary>\n Releases all allocations held by the buffer pool. The buffer pool remains in a usable state.\n </summary>\n <param name=\"handle\">Buffer pool to clear.</param>"]
    #[link_name = "\u{1}_ClearBufferPool"]
    pub fn Bepu_ClearBufferPool(handle: Bepu_BufferPoolHandle);
}
extern "C" {
    #[doc = " <summary>\n Releases all allocations held by the buffer pool and releases the buffer pool reference. The handle is invalidated.\n </summary>\n <param name=\"handle\">Buffer pool to destroy.</param>"]
    #[link_name = "\u{1}_DestroyBufferPool"]
    pub fn Bepu_DestroyBufferPool(handle: Bepu_BufferPoolHandle);
}
extern "C" {
    #[doc = " <summary>\n Allocates a buffer from the buffer pool of the given size.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to allocate from.</param>\n <param name=\"sizeInBytes\">Size of the buffer to allocate in bytes.</param>\n <returns>Allocated buffer.</returns>"]
    #[link_name = "\u{1}_Allocate"]
    pub fn Bepu_Allocate(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        sizeInBytes: i32,
    ) -> Bepu_ByteBuffer;
}
extern "C" {
    #[doc = " <summary>\n Allocates a buffer from the buffer pool with at least the given size.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to allocate from.</param>\n <param name=\"sizeInBytes\">Size of the buffer to allocate in bytes.</param>\n <returns>Allocated buffer.</returns>"]
    #[link_name = "\u{1}_AllocateAtLeast"]
    pub fn Bepu_AllocateAtLeast(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        sizeInBytes: i32,
    ) -> Bepu_ByteBuffer;
}
extern "C" {
    #[doc = " <summary>\n Resizes a buffer from the buffer pool to the given size, reallocating if necessary.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to allocate from.</param>\n <param name=\"buffer\">Buffer to resize.</param>\n <param name=\"newSizeInBytes\">Target size of the buffer to allocate in bytes.</param>\n <param name=\"copyCount\">Number of bytes to copy from the old buffer into the new buffer.</param>"]
    #[link_name = "\u{1}_Resize"]
    pub fn Bepu_Resize(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        buffer: *mut Bepu_ByteBuffer,
        newSizeInBytes: i32,
        copyCount: i32,
    );
}
extern "C" {
    #[doc = " <summary>\n Resizes a buffer from the buffer pool to at least the given size, reallocating if necessary.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to allocate from.</param>\n <param name=\"buffer\">Buffer to resize.</param>\n <param name=\"targetSizeInBytes\">Target size of the buffer to allocate in bytes.</param>\n <param name=\"copyCount\">Number of bytes to copy from the old buffer into the new buffer.</param>"]
    #[link_name = "\u{1}_ResizeToAtLeast"]
    pub fn Bepu_ResizeToAtLeast(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        buffer: *mut Bepu_ByteBuffer,
        targetSizeInBytes: i32,
        copyCount: i32,
    );
}
extern "C" {
    #[doc = " <summary>\n Returns a buffer to the buffer pool.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to return the buffer to.</param>\n <param name=\"buffer\">Buffer to return to the pool.</param>"]
    #[link_name = "\u{1}_Deallocate"]
    pub fn Bepu_Deallocate(bufferPoolHandle: Bepu_BufferPoolHandle, buffer: *mut Bepu_ByteBuffer);
}
extern "C" {
    #[doc = " <summary>\n Returns a buffer to the buffer pool by its id.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to return the buffer to.</param>\n <param name=\"bufferId\">Id of the buffer to return to the pool.</param>"]
    #[link_name = "\u{1}_DeallocateById"]
    pub fn Bepu_DeallocateById(bufferPoolHandle: Bepu_BufferPoolHandle, bufferId: i32);
}
extern "C" {
    #[doc = " <summary>\n Creates a new thread dispatcher.\n </summary>\n <param name=\"threadCount\">Number of threads to use within the thread dispatcher.</param>\n <param name=\"threadPoolAllocationBlockSize\">Minimum size in bytes of blocks allocated in per-thread buffer pools. Allocations requiring more space can result in larger block sizes, but no pools will allocate smaller blocks.</param>"]
    #[link_name = "\u{1}_CreateThreadDispatcher"]
    pub fn Bepu_CreateThreadDispatcher(
        threadCount: i32,
        threadPoolAllocationBlockSize: i32,
    ) -> Bepu_ThreadDispatcherHandle;
}
extern "C" {
    #[doc = " <summary>\n Releases all resources held by a thread dispatcher and invalidates its handle.\n </summary>\n <param name=\"handle\">Thread dispatcher to destroy.</param>"]
    #[link_name = "\u{1}_DestroyThreadDispatcher"]
    pub fn Bepu_DestroyThreadDispatcher(handle: Bepu_ThreadDispatcherHandle);
}
extern "C" {
    #[doc = " <summary>\n Releases all resources held by a thread dispatcher and invalidates its handle.\n </summary>\n <param name=\"handle\">Thread dispatcher to check the thread count of.</param>"]
    #[link_name = "\u{1}_GetThreadCount"]
    pub fn Bepu_GetThreadCount(handle: Bepu_ThreadDispatcherHandle) -> i32;
}
extern "C" {
    #[doc = " <summary>\n Creates a new simulation.\n </summary>\n <param name=\"bufferPool\">Buffer pool for the simulation's main allocations.</param>\n <param name=\"narrowPhaseCallbacks\">Narrow phase callbacks to be invoked by the simulation.</param>\n <param name=\"poseIntegratorCallbacks\">Pose integration state and callbacks to be invoked by the simulation.</param>\n <param name=\"solveDescriptionInterop\">Defines velocity iteration count and substep counts for the simulation's solver.</param>\n <param name=\"initialAllocationSizes\">Initial capacities to allocate within the simulation.</param>\n <returns></returns>"]
    #[link_name = "\u{1}_CreateSimulation"]
    pub fn Bepu_CreateSimulation(
        bufferPool: Bepu_BufferPoolHandle,
        narrowPhaseCallbacks: Bepu_NarrowPhaseCallbacks,
        poseIntegratorCallbacks: Bepu_PoseIntegratorCallbacks,
        solveDescriptionInterop: Bepu_SolveDescription,
        initialAllocationSizes: Bepu_SimulationAllocationSizes,
    ) -> Bepu_SimulationHandle;
}
extern "C" {
    #[link_name = "\u{1}_DestroySimulation"]
    pub fn Bepu_DestroySimulation(handle: Bepu_SimulationHandle);
}
extern "C" {
    #[link_name = "\u{1}_AddBody"]
    pub fn Bepu_AddBody(
        simulationHandle: Bepu_SimulationHandle,
        bodyDescription: Bepu_BodyDescription,
    ) -> Bepu_BodyHandle;
}
extern "C" {
    #[link_name = "\u{1}_RemoveBody"]
    pub fn Bepu_RemoveBody(simulationHandle: Bepu_SimulationHandle, bodyHandle: Bepu_BodyHandle);
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to the dynamic state associated with a body. Includes pose, velocity, and inertia.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a body's state from.</param>\n <param name=\"bodyHandle\">Body handle to pull data about.</param>\n <returns>Pointer to the body's dynamic state.</returns>\n <remarks>This is a direct pointer. The memory location associated with a body can move other bodies are removed from the simulation; do not hold a pointer beyond the point where it may be invalidated.</remarks>"]
    #[link_name = "\u{1}_GetBodyDynamics"]
    pub fn Bepu_GetBodyDynamics(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandle: Bepu_BodyHandle,
    ) -> *mut Bepu_BodyDynamics;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to the collidable associated with a body.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a body's state from.</param>\n <param name=\"bodyHandle\">Body handle to pull data about.</param>\n <returns>Pointer to the body's collidable.</returns>\n <remarks>This is a direct pointer. The memory location associated with a body can move if other bodies are removed from the simulation; do not hold a pointer beyond the point where it may be invalidated.</remarks>"]
    #[link_name = "\u{1}_GetBodyCollidable"]
    pub fn Bepu_GetBodyCollidable(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandle: Bepu_BodyHandle,
    ) -> *mut Bepu_Collidable;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to the activity state associated with a body.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a body's state from.</param>\n <param name=\"bodyHandle\">Body handle to pull data about.</param>\n <returns>Pointer to the body's activity state.</returns>\n <remarks>This is a direct pointer. The memory location associated with a body can move if other bodies are removed from the simulation; do not hold a pointer beyond the point where it may be invalidated.</remarks>"]
    #[link_name = "\u{1}_GetBodyActivity"]
    pub fn Bepu_GetBodyActivity(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandle: Bepu_BodyHandle,
    ) -> *mut Bepu_BodyActivity;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to the list of constraints associated with a body.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a body's state from.</param>\n <param name=\"bodyHandle\">Body handle to pull data about.</param>\n <returns>Pointer to the body's constraint list.</returns>\n <remarks>This is a direct pointer. The memory location associated with a body can move if other bodies are removed from the simulation; do not hold a pointer beyond the point where it may be invalidated.</remarks>"]
    #[link_name = "\u{1}_GetBodyConstraints"]
    pub fn Bepu_GetBodyConstraints(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandle: Bepu_BodyHandle,
    ) -> *mut Bepu_QuickList<Bepu_BodyConstraintReference>;
}
extern "C" {
    #[doc = " <summary>\n Gets a description of a body.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a body's state from.</param>\n <param name=\"bodyHandle\">Body handle to pull data about.</param>\n <returns>Description of a body.</returns>"]
    #[link_name = "\u{1}_GetBodyDescription"]
    pub fn Bepu_GetBodyDescription(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandle: Bepu_BodyHandle,
    ) -> Bepu_BodyDescription;
}
extern "C" {
    #[doc = " <summary>\n Applies a description to a body.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a body's state from.</param>\n <param name=\"bodyHandle\">Body handle to pull data about.</param>\n <param name=\"description\">Description to apply to the body.</param>"]
    #[link_name = "\u{1}_ApplyBodyDescription"]
    pub fn Bepu_ApplyBodyDescription(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandle: Bepu_BodyHandle,
        description: Bepu_BodyDescription,
    );
}
extern "C" {
    #[link_name = "\u{1}_AddStatic"]
    pub fn Bepu_AddStatic(
        simulationHandle: Bepu_SimulationHandle,
        staticDescription: Bepu_StaticDescription,
    ) -> Bepu_StaticHandle;
}
extern "C" {
    #[link_name = "\u{1}_RemoveStatic"]
    pub fn Bepu_RemoveStatic(
        simulationHandle: Bepu_SimulationHandle,
        staticHandle: Bepu_StaticHandle,
    );
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to data associated with a static.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a static's state from.</param>\n <param name=\"staticHandle\">Static handle to pull data about.</param>\n <returns>Pointer to the static's data.</returns>\n <remarks>This is a direct pointer. The memory location associated with a static can move if other statics are removed from the simulation; do not hold a pointer beyond the point where it may be invalidated.</remarks>"]
    #[link_name = "\u{1}_GetStatic"]
    pub fn Bepu_GetStatic(
        simulationHandle: Bepu_SimulationHandle,
        staticHandle: Bepu_StaticHandle,
    ) -> *mut Bepu_Static;
}
extern "C" {
    #[doc = " <summary>\n Gets a static's description.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a static's state from.</param>\n <param name=\"staticHandle\">Static handle to pull data about.</param>\n <returns>Description of the static..</returns>"]
    #[link_name = "\u{1}_GetStaticDescription"]
    pub fn Bepu_GetStaticDescription(
        simulationHandle: Bepu_SimulationHandle,
        staticHandle: Bepu_StaticHandle,
    ) -> Bepu_StaticDescription;
}
extern "C" {
    #[doc = " <summary>\n Applies a description to a static.\n </summary>\n <param name=\"simulationHandle\">Simulation to pull a static's state from.</param>\n <param name=\"staticHandle\">Static handle to pull data about.</param>"]
    #[link_name = "\u{1}_ApplyStaticDescription"]
    pub fn Bepu_ApplyStaticDescription(
        simulationHandle: Bepu_SimulationHandle,
        staticHandle: Bepu_StaticHandle,
        description: Bepu_StaticDescription,
    );
}
extern "C" {
    #[doc = " <summary>\n Steps the simulation forward a single time.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to step.</param>\n <param name=\"dt\">Duration of the timestep.</param>\n <param name=\"threadDispatcherHandle\">Handle of the thread dispatcher to use, if any. Can be a null reference.</param>"]
    #[link_name = "\u{1}_Timestep"]
    pub fn Bepu_Timestep(
        simulationHandle: Bepu_SimulationHandle,
        dt: f32,
        threadDispatcherHandle: Bepu_ThreadDispatcherHandle,
    );
}
extern "C" {
    #[doc = " <summary>\n Grabs a collidable's bounding boxes in the broad phase.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to pull data from.</param>\n <param name=\"bodyHandle\">Body to pull bounding box data about.</param>\n <param name=\"min\">Minimum bounds of the collidable's bounding box.</param>\n <param name=\"max\">Maximum bounds of the collidable's bounding box.</param>"]
    #[link_name = "\u{1}_GetBodyBoundingBoxInBroadPhase"]
    pub fn Bepu_GetBodyBoundingBoxInBroadPhase(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandle: Bepu_BodyHandle,
        min: *mut Bepu_Vector3,
        max: *mut Bepu_Vector3,
    );
}
extern "C" {
    #[doc = " <summary>\n Grabs a collidable's bounding boxes in the broad phase.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to pull data from.</param>\n <param name=\"staticHandle\">Static to pull bounding box data about.</param>\n <param name=\"min\">Minimum bounds of the collidable's bounding box.</param>\n <param name=\"max\">Maximum bounds of the collidable's bounding box.</param>"]
    #[link_name = "\u{1}_GetStaticBoundingBoxInBroadPhase"]
    pub fn Bepu_GetStaticBoundingBoxInBroadPhase(
        simulationHandle: Bepu_SimulationHandle,
        staticHandle: Bepu_StaticHandle,
        min: *mut Bepu_Vector3,
        max: *mut Bepu_Vector3,
    );
}
extern "C" {
    #[doc = " <summary>\n Gets the mapping from body handles to the body's location in storage.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to pull data from.</param>\n <param name=\"bodyHandleToIndexMapping\">Mapping from a body handle to the body's memory location.</param>\n <remarks>The buffer returned by this function can be invalidated if the simulation resizes it.</remarks>"]
    #[link_name = "\u{1}_GetBodyHandleToLocationMapping"]
    pub fn Bepu_GetBodyHandleToLocationMapping(
        simulationHandle: Bepu_SimulationHandle,
        bodyHandleToIndexMapping: *mut Bepu_Buffer<Bepu_BodyMemoryLocation>,
    );
}
extern "C" {
    #[doc = " <summary>\n Gets the body sets for a simulation. Slot 0 is the active set. Subsequent sets are sleeping. Not every slot beyond slot 0 is filled.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to pull data from.</param>\n <param name=\"bodySets\">Mapping from a body handle to the body's memory location.</param>\n <remarks>The buffer returned by this function can be invalidated if the simulation resizes it.</remarks>"]
    #[link_name = "\u{1}_GetBodySets"]
    pub fn Bepu_GetBodySets(
        simulationHandle: Bepu_SimulationHandle,
        bodySets: *mut Bepu_Buffer<Bepu_BodySet>,
    );
}
extern "C" {
    #[doc = " <summary>\n Gets the mapping from body handles to the body's location in storage.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to pull data from.</param>\n <param name=\"staticHandleToIndexMapping\">Mapping from a static handle to the static's memory location.</param>\n <remarks>The buffer returned by this function can be invalidated if the simulation resizes it.</remarks>"]
    #[link_name = "\u{1}_GetStaticHandleToLocationMapping"]
    pub fn Bepu_GetStaticHandleToLocationMapping(
        simulationHandle: Bepu_SimulationHandle,
        staticHandleToIndexMapping: *mut Bepu_Buffer<i32>,
    );
}
extern "C" {
    #[doc = " <summary>\n Gets the statics set for a simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to pull data from.</param>\n <param name=\"statics\">The set of all statics within a simulation.</param>\n <param name=\"count\">Number of statics in the simulation.</param>\n <remarks>The buffer returned by this function can be invalidated if the simulation resizes it. The count is a snapshot.</remarks>"]
    #[link_name = "\u{1}_GetStatics"]
    pub fn Bepu_GetStatics(
        simulationHandle: Bepu_SimulationHandle,
        statics: *mut Bepu_Buffer<Bepu_Static>,
        count: *mut i32,
    );
}
extern "C" {
    #[doc = " <summary>\n Computes the total number of bytes allocated from native memory in this buffer pool.\n Includes allocated memory regardless of whether it currently has outstanding references.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to check the allocation size of.</param>\n <returns>Total number of bytes allocated from native memory in this buffer pool.</returns>"]
    #[link_name = "\u{1}_GetAllocatedMemorySizeInPool"]
    pub fn Bepu_GetAllocatedMemorySizeInPool(bufferPoolHandle: Bepu_BufferPoolHandle) -> u64;
}
extern "C" {
    #[doc = " <summary>\n Computes the total number of bytes allocated from native memory in a dispatcher's per-thread pools.\n Includes allocated memory regardless of whether it currently has outstanding references.\n </summary>\n <param name=\"threadDispatcherHandle\">Thread dispatcher to check allocations for.</param>\n <returns>Total number of bytes allocated from native memory in this thread dispatcher's per-thread pool.</returns>"]
    #[link_name = "\u{1}_GetAllocatedMemorySizeInThreadDispatcher"]
    pub fn Bepu_GetAllocatedMemorySizeInThreadDispatcher(
        threadDispatcherHandle: Bepu_ThreadDispatcherHandle,
    ) -> u64;
}
extern "C" {
    #[doc = " <summary>\n Estimates the number of bytes managed by the garbage collector.\n </summary>\n <returns>Estimated number of bytes allocated from managed memory.</returns>"]
    #[link_name = "\u{1}_GetGCAllocatedMemorySize"]
    pub fn Bepu_GetGCAllocatedMemorySize() -> u64;
}
extern "C" {
    #[doc = " <summary>\n Adds a sphere shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"sphere\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddSphere"]
    pub fn Bepu_AddSphere(
        simulationHandle: Bepu_SimulationHandle,
        sphere: Bepu_Sphere,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a capsule shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"capsule\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddCapsule"]
    pub fn Bepu_AddCapsule(
        simulationHandle: Bepu_SimulationHandle,
        capsule: Bepu_Capsule,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a box shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"box\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddBox"]
    pub fn Bepu_AddBox(simulationHandle: Bepu_SimulationHandle, box_: Bepu_Box) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a triangle shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"triangle\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddTriangle"]
    pub fn Bepu_AddTriangle(
        simulationHandle: Bepu_SimulationHandle,
        triangle: Bepu_Triangle,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a cylinder shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"cylinder\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddCylinder"]
    pub fn Bepu_AddCylinder(
        simulationHandle: Bepu_SimulationHandle,
        cylinder: Bepu_Cylinder,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a convex hull shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"convexHull\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddConvexHull"]
    pub fn Bepu_AddConvexHull(
        simulationHandle: Bepu_SimulationHandle,
        convexHull: Bepu_ConvexHull,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a compound shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"bigCompound\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddCompound"]
    pub fn Bepu_AddCompound(
        simulationHandle: Bepu_SimulationHandle,
        bigCompound: Bepu_Compound,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a big compound shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"bigCompound\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddBigCompound"]
    pub fn Bepu_AddBigCompound(
        simulationHandle: Bepu_SimulationHandle,
        bigCompound: Bepu_BigCompound,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Adds a mesh shape to the simulation.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to add the shape to.</param>\n <param name=\"mesh\">Shape to add to the simulation.</param>"]
    #[link_name = "\u{1}_AddMesh"]
    pub fn Bepu_AddMesh(
        simulationHandle: Bepu_SimulationHandle,
        mesh: Bepu_Mesh,
    ) -> Bepu_TypedIndex;
}
extern "C" {
    #[doc = " <summary>\n Removes a shape from the simulation. Does not return any shape allocated buffers to buffer pools.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape to remove from the simulation.</param>"]
    #[link_name = "\u{1}_RemoveShape"]
    pub fn Bepu_RemoveShape(simulationHandle: Bepu_SimulationHandle, shape: Bepu_TypedIndex);
}
extern "C" {
    #[doc = " <summary>\n Removes a shape from the simulation. If the shape has resources that were allocated from a buffer pool, they will be returned to the specified pool.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"bufferPoolHandle\">Buffer pool to return shape resources to, if any.</param>\n <param name=\"shape\">Shape to remove from the simulation.</param>\n <remarks>The same buffer pool must be used for both allocation and deallocation.</remarks>"]
    #[link_name = "\u{1}_RemoveAndDestroyShape"]
    pub fn Bepu_RemoveAndDestroyShape(
        simulationHandle: Bepu_SimulationHandle,
        bufferPoolHandle: Bepu_BufferPoolHandle,
        shape: Bepu_TypedIndex,
    );
}
extern "C" {
    #[doc = " <summary>\n Removes a shape and all references child shapes from the simulation. If the shapes had resources that were allocated from a buffer pool, they will be returned to the specified pool.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"bufferPoolHandle\">Buffer pool to return shape resources to, if any.</param>\n <param name=\"shape\">Shape to remove from the simulation.</param>\n <remarks>The same buffer pool must be used for both allocation and deallocation.</remarks>"]
    #[link_name = "\u{1}_RemoveAndDestroyShapeRecursively"]
    pub fn Bepu_RemoveAndDestroyShapeRecursively(
        simulationHandle: Bepu_SimulationHandle,
        bufferPoolHandle: Bepu_BufferPoolHandle,
        shape: Bepu_TypedIndex,
    );
}
extern "C" {
    #[doc = " <summary>\n Creates a convex hull shape from a point set.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to allocate resources from for the compound's acceleration structures.</param>\n <param name=\"points\">Points in the convex hull.</param>\n <param name=\"centerOfMass\">Center of mass computed for the hull and subtracted from all the points in the points used for the final shape.</param>"]
    #[link_name = "\u{1}_CreateConvexHull"]
    pub fn Bepu_CreateConvexHull(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        points: Bepu_Buffer<Bepu_Vector3>,
        centerOfMass: *mut Bepu_Vector3,
    ) -> Bepu_ConvexHull;
}
extern "C" {
    #[doc = " <summary>\n Returns buffers allocated for a convex hull shape.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to return resources to. Must be the same pool that resources were allocated from.</param>\n <param name=\"convexHull\">Convex hull to destroy.</param>"]
    #[link_name = "\u{1}_DestroyConvexHull"]
    pub fn Bepu_DestroyConvexHull(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        convexHull: *mut Bepu_ConvexHull,
    );
}
extern "C" {
    #[doc = " <summary>\n Returns buffers allocated for a compound shape.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to return resources to. Must be the same pool that resources were allocated from.</param>\n <param name=\"compound\">Compound to destroy.</param>"]
    #[link_name = "\u{1}_DestroyCompound"]
    pub fn Bepu_DestroyCompound(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        compound: *mut Bepu_Compound,
    );
}
extern "C" {
    #[doc = " <summary>\n Creates a big compound shape from a list of children.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to which the shapes referenced by the compound children belong.</param>\n <param name=\"bufferPoolHandle\">Buffer pool to allocate resources from for the compound's acceleration structures.</param>\n <param name=\"children\">Children of the compound.</param>"]
    #[link_name = "\u{1}_CreateBigCompound"]
    pub fn Bepu_CreateBigCompound(
        simulationHandle: Bepu_SimulationHandle,
        bufferPoolHandle: Bepu_BufferPoolHandle,
        children: Bepu_Buffer<Bepu_CompoundChild>,
    ) -> Bepu_BigCompound;
}
extern "C" {
    #[doc = " <summary>\n Returns buffers allocated for a big compound shape.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to return resources to. Must be the same pool that resources were allocated from.</param>\n <param name=\"bigCompound\">Big compound to destroy.</param>"]
    #[link_name = "\u{1}_DestroyBigCompound"]
    pub fn Bepu_DestroyBigCompound(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        bigCompound: *mut Bepu_BigCompound,
    );
}
extern "C" {
    #[doc = " <summary>\n Creates a mesh shape from triangles.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to allocate resources from for the compound's acceleration structures.</param>\n <param name=\"triangles\">Triangles composing the mesh.</param>\n <param name=\"scale\">Scale of the mesh.</param>\n <remarks>This uses a pretty old sweep builder. Large meshes will take a while. There are ways to do this much faster if required; see https://github.com/bepu/bepuphysics2/blob/master/Demos/DemoMeshHelper.cs#L186.</remarks>"]
    #[link_name = "\u{1}_CreateMesh"]
    pub fn Bepu_CreateMesh(
        bufferPoolHandle: Bepu_BufferPoolHandle,
        triangles: Bepu_Buffer<Bepu_Triangle>,
        scale: Bepu_Vector3,
    ) -> Bepu_Mesh;
}
extern "C" {
    #[doc = " <summary>\n Returns buffers allocated for a mesh shape.\n </summary>\n <param name=\"bufferPoolHandle\">Buffer pool to return resources to. Must be the same pool that resources were allocated from.</param>\n <param name=\"mesh\">Mesh to destroy.</param>"]
    #[link_name = "\u{1}_DestroyMesh"]
    pub fn Bepu_DestroyMesh(bufferPoolHandle: Bepu_BufferPoolHandle, mesh: *mut Bepu_Mesh);
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia of a sphere.\n </summary>\n <param name=\"sphere\">Shape to compute the inertia of.</param>\n <param name=\"mass\">Mass to use in the inertia calculation.</param>\n <returns>Inertia of the shape.</returns>"]
    #[link_name = "\u{1}_ComputeSphereInertia"]
    pub fn Bepu_ComputeSphereInertia(sphere: Bepu_Sphere, mass: f32) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia of a capsule.\n </summary>\n <param name=\"capsule\">Shape to compute the inertia of.</param>\n <param name=\"mass\">Mass to use in the inertia calculation.</param>\n <returns>Inertia of the shape.</returns>"]
    #[link_name = "\u{1}_ComputeCapsuleInertia"]
    pub fn Bepu_ComputeCapsuleInertia(capsule: Bepu_Capsule, mass: f32) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia of a box.\n </summary>\n <param name=\"box\">Shape to compute the inertia of.</param>\n <param name=\"mass\">Mass to use in the inertia calculation.</param>\n <returns>Inertia of the shape.</returns>"]
    #[link_name = "\u{1}_ComputeBoxInertia"]
    pub fn Bepu_ComputeBoxInertia(box_: Bepu_Box, mass: f32) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia of a triangle.\n </summary>\n <param name=\"triangle\">Shape to compute the inertia of.</param>\n <param name=\"mass\">Mass to use in the inertia calculation.</param>\n <returns>Inertia of the shape.</returns>"]
    #[link_name = "\u{1}_ComputeTriangleInertia"]
    pub fn Bepu_ComputeTriangleInertia(triangle: Bepu_Triangle, mass: f32) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia of a cylinder.\n </summary>\n <param name=\"cylinder\">Shape to compute the inertia of.</param>\n <param name=\"mass\">Mass to use in the inertia calculation.</param>\n <returns>Inertia of the shape.</returns>"]
    #[link_name = "\u{1}_ComputeCylinderInertia"]
    pub fn Bepu_ComputeCylinderInertia(cylinder: Bepu_Cylinder, mass: f32) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia of a convex hull.\n </summary>\n <param name=\"convexHull\">Shape to compute the inertia of.</param>\n <param name=\"mass\">Mass to use in the inertia calculation.</param>\n <returns>Inertia of the shape.</returns>"]
    #[link_name = "\u{1}_ComputeConvexHullInertia"]
    pub fn Bepu_ComputeConvexHullInertia(
        convexHull: Bepu_ConvexHull,
        mass: f32,
    ) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia of a convex.\n </summary>\n <param name=\"convex\">Index of a convex to calculate the inertia for.</param>\n <param name=\"mass\">Mass to use in the inertia calculation.</param>\n <returns>Inertia of the shape. If the shape index was not a convex, this returns a zeroed inverse inertia tensor.</returns>"]
    #[link_name = "\u{1}_ComputeConvexInertia"]
    pub fn Bepu_ComputeConvexInertia(
        simulationHandle: Bepu_SimulationHandle,
        convex: Bepu_TypedIndex,
        mass: f32,
    ) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia associated with a set of compound children. Does not recenter the children.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to which the shapes referenced by the compound children belong.</param>\n <param name=\"children\">Children of the compound.</param>\n <param name=\"childMasses\">Masses of the children composing the compound.</param>"]
    #[link_name = "\u{1}_ComputeCompoundInertia"]
    pub fn Bepu_ComputeCompoundInertia(
        simulationHandle: Bepu_SimulationHandle,
        children: Bepu_Buffer<Bepu_CompoundChild>,
        childMasses: Bepu_Buffer<f32>,
    ) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia associated with a set of compound children. Recenters all children onto the computed local center of mass.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to which the shapes referenced by the compound children belong.</param>\n <param name=\"children\">Children of the compound.</param>\n <param name=\"childMasses\">Masses of the children composing the compound.</param>\n <param name=\"centerOfMass\">Computed center of mass that was subtracted from the position of compound children.</param>"]
    #[link_name = "\u{1}_ComputeCompoundInertiaWithRecentering"]
    pub fn Bepu_ComputeCompoundInertiaWithRecentering(
        simulationHandle: Bepu_SimulationHandle,
        children: Bepu_Buffer<Bepu_CompoundChild>,
        childMasses: Bepu_Buffer<f32>,
        centerOfMass: *mut Bepu_Vector3,
    ) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia associated with a mesh by treating its triangles as a soup with no volume. Does not recenter the triangles on a computed center of mass.\n </summary>\n <param name=\"mesh\">Mesh to compute the inertia of.</param>\n <param name=\"mass\">Mass of the mesh.</param>"]
    #[link_name = "\u{1}_ComputeOpenMeshInertia"]
    pub fn Bepu_ComputeOpenMeshInertia(mesh: Bepu_Mesh, mass: f32) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia associated with a mesh by treating it as a closed volume. Does not recenter the triangles on a computed center of mass.\n </summary>\n <param name=\"mesh\">Mesh to compute the inertia of.</param>\n <param name=\"mass\">Mass of the mesh.</param>"]
    #[link_name = "\u{1}_ComputeClosedMeshInertia"]
    pub fn Bepu_ComputeClosedMeshInertia(mesh: Bepu_Mesh, mass: f32) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia associated with a mesh by treating its triangles as a soup with no volume. Recenters all children onto the computed local center of mass.\n </summary>\n <param name=\"mesh\">Mesh to compute the inertia of.</param>\n <param name=\"mass\">Mass of the mesh.</param>"]
    #[link_name = "\u{1}_ComputeOpenMeshInertiaWithRecentering"]
    pub fn Bepu_ComputeOpenMeshInertiaWithRecentering(
        mesh: Bepu_Mesh,
        mass: f32,
        centerOfMass: *mut Bepu_Vector3,
    ) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Computes the inertia associated with a mesh by treating it as a closed volume. Recenters all children onto the computed local center of mass.\n </summary>\n <param name=\"mesh\">Mesh to compute the inertia of.</param>\n <param name=\"mass\">Mass of the mesh.</param>"]
    #[link_name = "\u{1}_ComputeClosedMeshInertiaWithRecentering"]
    pub fn Bepu_ComputeClosedMeshInertiaWithRecentering(
        mesh: Bepu_Mesh,
        mass: f32,
        centerOfMass: *mut Bepu_Vector3,
    ) -> Bepu_BodyInertia;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a sphere shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetSphereShapeData"]
    pub fn Bepu_GetSphereShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_Sphere;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a capsule shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetCapsuleShapeData"]
    pub fn Bepu_GetCapsuleShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_Capsule;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a box shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetBoxShapeData"]
    pub fn Bepu_GetBoxShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_Box;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a triangle shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetTriangleShapeData"]
    pub fn Bepu_GetTriangleShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_Triangle;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a cylinder shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetCylinderShapeData"]
    pub fn Bepu_GetCylinderShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_Cylinder;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a convex hull shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetConvexHullShapeData"]
    pub fn Bepu_GetConvexHullShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_ConvexHull;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a compound shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetCompoundShapeData"]
    pub fn Bepu_GetCompoundShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_Compound;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a big compound shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetBigCompoundShapeData"]
    pub fn Bepu_GetBigCompoundShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_BigCompound;
}
extern "C" {
    #[doc = " <summary>\n Gets a pointer to a mesh shape's data stored within the simulation's shapes buffers.\n </summary>\n <param name=\"simulationHandle\">Handle of the simulation to remove the shape from.</param>\n <param name=\"shape\">Shape reference to request from the simulation.</param>\n <returns>Pointer to the shape's data in the simulation's shapes buffers.</returns>"]
    #[link_name = "\u{1}_GetMeshShapeData"]
    pub fn Bepu_GetMeshShapeData(
        simulationHandle: Bepu_SimulationHandle,
        shape: Bepu_TypedIndex,
    ) -> *mut Bepu_Mesh;
}
#[doc = " <summary>\n Convenience collection that stores extra properties about bodies and statics, indexed by the body or static handle.\n </summary>\n <typeparam name=\"T\">Type of the data to store.</typeparam>\n <remarks>This is built for use cases relying on random access like the narrow phase. For maximum performance with sequential access, an index-aligned structure would be better.</remarks>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bepu_CollidableProperty<T> {
    pub Simulation: Bepu_SimulationHandle,
    pub Pool: Bepu_BufferPoolHandle,
    pub bodyData: Bepu_Buffer<T>,
    pub staticData: Bepu_Buffer<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type max_align_t = f64;
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___type_list_open0_signed_char_std___type_list_open1_short_std___type_list_open2_int_std___type_list_open3_long_std___type_list_open4_long_long_std___type_list_open5___int128_t_std___nat_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___type_list>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___type_list)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_list>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___type_list)
        )
    );
}
pub type __int128_t = i128;
#[test]
fn __bindgen_test_layout_std___type_list_open0_unsigned_char_std___type_list_open1_unsigned_short_std___type_list_open2_unsigned_int_std___type_list_open3_unsigned_long_std___type_list_open4_unsigned_long_long_std___type_list_open5___uint128_t_std___nat_close5_close4_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___type_list>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___type_list)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___type_list>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___type_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_Node_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_Node>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Node>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_Node>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Node>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_Metanode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_Metanode>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Metanode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_Metanode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Metanode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_Leaf_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_Leaf>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Leaf>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_Leaf>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Leaf>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_Vector3Wide_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_Vector3Wide>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Vector3Wide>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_Vector3Wide>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Vector3Wide>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_HullBoundingPlanes_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_HullBoundingPlanes>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_HullBoundingPlanes>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_HullBoundingPlanes>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_HullBoundingPlanes>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_HullVertexIndex_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_HullVertexIndex>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_HullVertexIndex>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_HullVertexIndex>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_HullVertexIndex>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_int32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<i32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<i32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_CompoundChild_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_CompoundChild_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_Triangle_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_Triangle>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Triangle>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_Triangle>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Triangle>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_BodyHandle_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_BodyHandle>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyHandle>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_BodyHandle>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyHandle>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_BodyDynamics_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_BodyDynamics>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyDynamics>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_BodyDynamics>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyDynamics>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_Collidable_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_Collidable>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Collidable>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_Collidable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Collidable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_BodyActivity_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_BodyActivity>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyActivity>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_BodyActivity>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyActivity>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_QuickList_open1_Bepu_BodyConstraintReference_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_QuickList<Bepu_BodyConstraintReference>>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_QuickList<Bepu_BodyConstraintReference>>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_QuickList<Bepu_BodyConstraintReference>>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_QuickList<Bepu_BodyConstraintReference>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_BodyMemoryLocation_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_BodyMemoryLocation>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyMemoryLocation>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_BodyMemoryLocation>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_BodyMemoryLocation>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_int32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<i32>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<i32>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_CompoundChild_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_Triangle_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_Triangle>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Triangle>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_Triangle>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_Triangle>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_CompoundChild_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Bepu_Buffer_open0_Bepu_CompoundChild_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Bepu_Buffer<Bepu_CompoundChild>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Bepu_Buffer<Bepu_CompoundChild>)
        )
    );
}
